
eu.fpetersen.yarp.bluetoothconf.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003a  00800100  00001262  000012f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001262  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000112  0080013a  0080013a  00001330  2**0
                  ALLOC
  3 .debug_aranges 000005c0  00000000  00000000  00001330  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000ea4  00000000  00000000  000018f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00007f16  00000000  00000000  00002794  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001523  00000000  00000000  0000a6aa  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00003252  00000000  00000000  0000bbcd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000a60  00000000  00000000  0000ee20  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001a97  00000000  00000000  0000f880  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003c69  00000000  00000000  00011317  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000005f0  00000000  00000000  00014f80  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
    SREG = oldSREG;
    return true;
  }

  return false;
}
       0:	0c 94 ac 00 	jmp	0x158	; 0x158 <__dtors_end>

HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
  volatile uint8_t *udr,
  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
       4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
    n += write(*buffer++);
  }
  return n;
}

size_t Print::print(const __FlashStringHelper *ifsh)
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
	timer0_millis = m;
	timer0_overflow_count++;
}

unsigned long millis()
{
       c:	0c 94 40 01 	jmp	0x280	; 0x280 <__vector_3>

	SREG = oldSREG;
}

int digitalRead(uint8_t pin)
{
      10:	0c 94 6a 01 	jmp	0x2d4	; 0x2d4 <__vector_4>
      14:	0c 94 94 01 	jmp	0x328	; 0x328 <__vector_5>
      18:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 66 07 	jmp	0xecc	; 0xecc <__vector_16>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 e9 04 	jmp	0x9d2	; 0x9d2 <__vector_18>
      4c:	0c 94 30 05 	jmp	0xa60	; 0xa60 <__vector_19>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>

00000068 <_ZL5table>:
      68:	00 c2 01 00 01 00 11 00 11 00 0c 00 00 e1 00 00     ................
      78:	0a 00 25 00 25 00 21 00 00 96 00 00 19 00 39 00     ..%.%.!.......9.
      88:	39 00 36 00 12 7a 00 00 1f 00 46 00 46 00 44 00     9.6..z....F.F.D.
      98:	80 70 00 00 22 00 4d 00 4d 00 4a 00 00 4b 00 00     .p..".M.M.J..K..
      a8:	36 00 75 00 75 00 72 00 40 38 00 00 4a 00 9c 00     6.u.u.r.@8..J...
      b8:	9c 00 99 00 80 25 00 00 72 00 ec 00 ec 00 e9 00     .....%..r.......
      c8:	c0 12 00 00 e9 00 da 01 da 01 d7 01 60 09 00 00     ............`...
      d8:	d7 01 b6 03 b6 03 b3 03 b0 04 00 00 b3 03 6e 07     ..............n.
      e8:	6e 07 6b 07 2c 01 00 00 dc 0e c1 1d c1 1d be 1d     n.k.,...........

000000f8 <port_to_mode_PGM>:
      f8:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

00000102 <port_to_output_PGM>:
     102:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

0000010c <port_to_input_PGM>:
     10c:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

00000116 <digital_pin_to_port_PGM>:
     116:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
     126:	03 03 03 03                                         ....

0000012a <digital_pin_to_bit_mask_PGM>:
     12a:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
     13a:	04 08 10 20                                         ... 

0000013e <digital_pin_to_timer_PGM>:
     13e:	00 00 00 07 00 02 01 00 00 03 04 06 00 00 00 00     ................
     14e:	00 00 00 00                                         ....

00000152 <__ctors_start>:
     152:	76 04       	cpc	r7, r6
     154:	96 06       	cpc	r9, r22

00000156 <__ctors_end>:
     156:	6f 04       	cpc	r6, r15

00000158 <__dtors_end>:
     158:	11 24       	eor	r1, r1
     15a:	1f be       	out	0x3f, r1	; 63
     15c:	cf ef       	ldi	r28, 0xFF	; 255
     15e:	d8 e0       	ldi	r29, 0x08	; 8
     160:	de bf       	out	0x3e, r29	; 62
     162:	cd bf       	out	0x3d, r28	; 61

00000164 <__do_copy_data>:
     164:	11 e0       	ldi	r17, 0x01	; 1
     166:	a0 e0       	ldi	r26, 0x00	; 0
     168:	b1 e0       	ldi	r27, 0x01	; 1
     16a:	e2 e6       	ldi	r30, 0x62	; 98
     16c:	f2 e1       	ldi	r31, 0x12	; 18
     16e:	02 c0       	rjmp	.+4      	; 0x174 <.do_copy_data_start>

00000170 <.do_copy_data_loop>:
     170:	05 90       	lpm	r0, Z+
     172:	0d 92       	st	X+, r0

00000174 <.do_copy_data_start>:
     174:	aa 33       	cpi	r26, 0x3A	; 58
     176:	b1 07       	cpc	r27, r17
     178:	d9 f7       	brne	.-10     	; 0x170 <.do_copy_data_loop>

0000017a <__do_clear_bss>:
     17a:	12 e0       	ldi	r17, 0x02	; 2
     17c:	aa e3       	ldi	r26, 0x3A	; 58
     17e:	b1 e0       	ldi	r27, 0x01	; 1
     180:	01 c0       	rjmp	.+2      	; 0x184 <.do_clear_bss_start>

00000182 <.do_clear_bss_loop>:
     182:	1d 92       	st	X+, r1

00000184 <.do_clear_bss_start>:
     184:	ac 34       	cpi	r26, 0x4C	; 76
     186:	b1 07       	cpc	r27, r17
     188:	e1 f7       	brne	.-8      	; 0x182 <.do_clear_bss_loop>

0000018a <__do_global_ctors>:
     18a:	11 e0       	ldi	r17, 0x01	; 1
     18c:	c6 e5       	ldi	r28, 0x56	; 86
     18e:	d1 e0       	ldi	r29, 0x01	; 1
     190:	04 c0       	rjmp	.+8      	; 0x19a <.do_global_ctors_start>

00000192 <.do_global_ctors_loop>:
     192:	22 97       	sbiw	r28, 0x02	; 2
     194:	fe 01       	movw	r30, r28
     196:	0e 94 20 09 	call	0x1240	; 0x1240 <__tablejump__>

0000019a <.do_global_ctors_start>:
     19a:	c2 35       	cpi	r28, 0x52	; 82
     19c:	d1 07       	cpc	r29, r17
     19e:	c9 f7       	brne	.-14     	; 0x192 <.do_global_ctors_loop>
     1a0:	0e 94 57 07 	call	0xeae	; 0xeae <main>
     1a4:	0c 94 24 09 	jmp	0x1248	; 0x1248 <__do_global_dtors>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <_ZN14SoftwareSerial4recvEv>:

//
// The receive routine called by the interrupt handler
//
void SoftwareSerial::recv()
     1ac:	0f 93       	push	r16
     1ae:	1f 93       	push	r17
     1b0:	cf 93       	push	r28
     1b2:	df 93       	push	r29
     1b4:	fc 01       	movw	r30, r24

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
     1b6:	73 8d       	ldd	r23, Z+27	; 0x1b
     1b8:	76 95       	lsr	r23
     1ba:	71 70       	andi	r23, 0x01	; 1
     1bc:	a6 85       	ldd	r26, Z+14	; 0x0e
     1be:	b7 85       	ldd	r27, Z+15	; 0x0f
     1c0:	95 85       	ldd	r25, Z+13	; 0x0d
     1c2:	77 23       	and	r23, r23
     1c4:	29 f0       	breq	.+10     	; 0x1d0 <_ZN14SoftwareSerial4recvEv+0x24>
    *_transmitPortRegister |= _transmitBitMask;
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
     1c6:	8c 91       	ld	r24, X

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
     1c8:	89 23       	and	r24, r25
     1ca:	09 f4       	brne	.+2      	; 0x1ce <_ZN14SoftwareSerial4recvEv+0x22>
     1cc:	54 c0       	rjmp	.+168    	; 0x276 <_ZN14SoftwareSerial4recvEv+0xca>
     1ce:	04 c0       	rjmp	.+8      	; 0x1d8 <_ZN14SoftwareSerial4recvEv+0x2c>
    *_transmitPortRegister |= _transmitBitMask;
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
     1d0:	8c 91       	ld	r24, X

  uint8_t d = 0;

  // If RX line is high, then we don't see any start bit
  // so interrupt is probably not for us
  if (_inverse_logic ? rx_pin_read() : !rx_pin_read())
     1d2:	89 23       	and	r24, r25
     1d4:	09 f0       	breq	.+2      	; 0x1d8 <_ZN14SoftwareSerial4recvEv+0x2c>
     1d6:	4f c0       	rjmp	.+158    	; 0x276 <_ZN14SoftwareSerial4recvEv+0xca>
  {
    // Wait approximately 1/2 of a bit width to "center" the sample
    tunedDelay(_rx_delay_centering);
     1d8:	83 89       	ldd	r24, Z+19	; 0x13
     1da:	94 89       	ldd	r25, Z+20	; 0x14
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     1dc:	20 e0       	ldi	r18, 0x00	; 0
     1de:	01 97       	sbiw	r24, 0x01	; 1
     1e0:	2f ef       	ldi	r18, 0xFF	; 255
     1e2:	8f 3f       	cpi	r24, 0xFF	; 255
     1e4:	92 07       	cpc	r25, r18
     1e6:	d9 f7       	brne	.-10     	; 0x1de <_ZN14SoftwareSerial4recvEv+0x32>
    DebugPulse(_DEBUG_PIN2, 1);

    // Read each of the 8 bits
    for (uint8_t i=0x1; i; i <<= 1)
    {
      tunedDelay(_rx_delay_intrabit);
     1e8:	c5 89       	ldd	r28, Z+21	; 0x15
     1ea:	d6 89       	ldd	r29, Z+22	; 0x16
    *_transmitPortRegister |= _transmitBitMask;
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
     1ec:	a6 85       	ldd	r26, Z+14	; 0x0e
     1ee:	b7 85       	ldd	r27, Z+15	; 0x0f
     1f0:	15 85       	ldd	r17, Z+13	; 0x0d
     1f2:	60 e0       	ldi	r22, 0x00	; 0
     1f4:	31 e0       	ldi	r19, 0x01	; 1
     1f6:	40 e0       	ldi	r20, 0x00	; 0
     1f8:	50 e0       	ldi	r21, 0x00	; 0
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     1fa:	00 e0       	ldi	r16, 0x00	; 0
     1fc:	ce 01       	movw	r24, r28
     1fe:	20 2f       	mov	r18, r16
     200:	01 97       	sbiw	r24, 0x01	; 1
     202:	2f ef       	ldi	r18, 0xFF	; 255
     204:	8f 3f       	cpi	r24, 0xFF	; 255
     206:	92 07       	cpc	r25, r18
     208:	d9 f7       	brne	.-10     	; 0x200 <_ZN14SoftwareSerial4recvEv+0x54>
    *_transmitPortRegister |= _transmitBitMask;
}

uint8_t SoftwareSerial::rx_pin_read()
{
  return *_receivePortRegister & _receiveBitMask;
     20a:	8c 91       	ld	r24, X
    for (uint8_t i=0x1; i; i <<= 1)
    {
      tunedDelay(_rx_delay_intrabit);
      DebugPulse(_DEBUG_PIN2, 1);
      uint8_t noti = ~i;
      if (rx_pin_read())
     20c:	81 23       	and	r24, r17
     20e:	11 f0       	breq	.+4      	; 0x214 <_ZN14SoftwareSerial4recvEv+0x68>
        d |= i;
     210:	63 2b       	or	r22, r19
     212:	03 c0       	rjmp	.+6      	; 0x21a <_ZN14SoftwareSerial4recvEv+0x6e>
      else // else clause added to ensure function timing is ~balanced
        d &= noti;
     214:	83 2f       	mov	r24, r19
     216:	80 95       	com	r24
     218:	68 23       	and	r22, r24
    // Wait approximately 1/2 of a bit width to "center" the sample
    tunedDelay(_rx_delay_centering);
    DebugPulse(_DEBUG_PIN2, 1);

    // Read each of the 8 bits
    for (uint8_t i=0x1; i; i <<= 1)
     21a:	33 0f       	add	r19, r19
     21c:	4f 5f       	subi	r20, 0xFF	; 255
     21e:	5f 4f       	sbci	r21, 0xFF	; 255
     220:	48 30       	cpi	r20, 0x08	; 8
     222:	51 05       	cpc	r21, r1
     224:	59 f7       	brne	.-42     	; 0x1fc <_ZN14SoftwareSerial4recvEv+0x50>
      else // else clause added to ensure function timing is ~balanced
        d &= noti;
    }

    // skip the stop bit
    tunedDelay(_rx_delay_stopbit);
     226:	87 89       	ldd	r24, Z+23	; 0x17
     228:	90 8d       	ldd	r25, Z+24	; 0x18
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     22a:	20 e0       	ldi	r18, 0x00	; 0
     22c:	01 97       	sbiw	r24, 0x01	; 1
     22e:	2f ef       	ldi	r18, 0xFF	; 255
     230:	8f 3f       	cpi	r24, 0xFF	; 255
     232:	92 07       	cpc	r25, r18
     234:	d9 f7       	brne	.-10     	; 0x22c <_ZN14SoftwareSerial4recvEv+0x80>

    // skip the stop bit
    tunedDelay(_rx_delay_stopbit);
    DebugPulse(_DEBUG_PIN2, 1);

    if (_inverse_logic)
     236:	71 11       	cpse	r23, r1
      d = ~d;
     238:	60 95       	com	r22

    // if buffer full, set the overflow flag and return
    if ((_receive_buffer_tail + 1) % _SS_MAX_RX_BUFF != _receive_buffer_head) 
     23a:	80 91 7c 01 	lds	r24, 0x017C
     23e:	20 91 7d 01 	lds	r18, 0x017D
     242:	90 e0       	ldi	r25, 0x00	; 0
     244:	01 96       	adiw	r24, 0x01	; 1
     246:	8f 73       	andi	r24, 0x3F	; 63
     248:	90 70       	andi	r25, 0x00	; 0
     24a:	30 e0       	ldi	r19, 0x00	; 0
     24c:	82 17       	cp	r24, r18
     24e:	93 07       	cpc	r25, r19
     250:	79 f0       	breq	.+30     	; 0x270 <_ZN14SoftwareSerial4recvEv+0xc4>
    {
      // save new data in buffer: tail points to where byte goes
      _receive_buffer[_receive_buffer_tail] = d; // save new byte
     252:	e0 91 7c 01 	lds	r30, 0x017C
     256:	f0 e0       	ldi	r31, 0x00	; 0
     258:	e4 5c       	subi	r30, 0xC4	; 196
     25a:	fe 4f       	sbci	r31, 0xFE	; 254
     25c:	60 83       	st	Z, r22
      _receive_buffer_tail = (_receive_buffer_tail + 1) % _SS_MAX_RX_BUFF;
     25e:	80 91 7c 01 	lds	r24, 0x017C
     262:	90 e0       	ldi	r25, 0x00	; 0
     264:	01 96       	adiw	r24, 0x01	; 1
     266:	8f 73       	andi	r24, 0x3F	; 63
     268:	90 70       	andi	r25, 0x00	; 0
     26a:	80 93 7c 01 	sts	0x017C, r24
     26e:	03 c0       	rjmp	.+6      	; 0x276 <_ZN14SoftwareSerial4recvEv+0xca>
    else 
    {
#if _DEBUG // for scope: pulse pin as overflow indictator
      DebugPulse(_DEBUG_PIN1, 1);
#endif
      _buffer_overflow = true;
     270:	83 8d       	ldd	r24, Z+27	; 0x1b
     272:	81 60       	ori	r24, 0x01	; 1
     274:	83 8f       	std	Z+27, r24	; 0x1b
    "pop r20 \n\t"
    "pop r19 \n\t"
    "pop r18 \n\t"
    ::);
#endif
}
     276:	df 91       	pop	r29
     278:	cf 91       	pop	r28
     27a:	1f 91       	pop	r17
     27c:	0f 91       	pop	r16
     27e:	08 95       	ret

00000280 <__vector_3>:
    active_object->recv();
  }
}

#if defined(PCINT0_vect)
ISR(PCINT0_vect)
     280:	1f 92       	push	r1
     282:	0f 92       	push	r0
     284:	0f b6       	in	r0, 0x3f	; 63
     286:	0f 92       	push	r0
     288:	11 24       	eor	r1, r1
     28a:	2f 93       	push	r18
     28c:	3f 93       	push	r19
     28e:	4f 93       	push	r20
     290:	5f 93       	push	r21
     292:	6f 93       	push	r22
     294:	7f 93       	push	r23
     296:	8f 93       	push	r24
     298:	9f 93       	push	r25
     29a:	af 93       	push	r26
     29c:	bf 93       	push	r27
     29e:	ef 93       	push	r30
     2a0:	ff 93       	push	r31
//

/* static */
inline void SoftwareSerial::handle_interrupt()
{
  if (active_object)
     2a2:	80 91 3a 01 	lds	r24, 0x013A
     2a6:	90 91 3b 01 	lds	r25, 0x013B
     2aa:	00 97       	sbiw	r24, 0x00	; 0
     2ac:	11 f0       	breq	.+4      	; 0x2b2 <__vector_3+0x32>
  {
    active_object->recv();
     2ae:	0e 94 d6 00 	call	0x1ac	; 0x1ac <_ZN14SoftwareSerial4recvEv>

#if defined(PCINT0_vect)
ISR(PCINT0_vect)
{
  SoftwareSerial::handle_interrupt();
}
     2b2:	ff 91       	pop	r31
     2b4:	ef 91       	pop	r30
     2b6:	bf 91       	pop	r27
     2b8:	af 91       	pop	r26
     2ba:	9f 91       	pop	r25
     2bc:	8f 91       	pop	r24
     2be:	7f 91       	pop	r23
     2c0:	6f 91       	pop	r22
     2c2:	5f 91       	pop	r21
     2c4:	4f 91       	pop	r20
     2c6:	3f 91       	pop	r19
     2c8:	2f 91       	pop	r18
     2ca:	0f 90       	pop	r0
     2cc:	0f be       	out	0x3f, r0	; 63
     2ce:	0f 90       	pop	r0
     2d0:	1f 90       	pop	r1
     2d2:	18 95       	reti

000002d4 <__vector_4>:
#endif

#if defined(PCINT1_vect)
ISR(PCINT1_vect)
     2d4:	1f 92       	push	r1
     2d6:	0f 92       	push	r0
     2d8:	0f b6       	in	r0, 0x3f	; 63
     2da:	0f 92       	push	r0
     2dc:	11 24       	eor	r1, r1
     2de:	2f 93       	push	r18
     2e0:	3f 93       	push	r19
     2e2:	4f 93       	push	r20
     2e4:	5f 93       	push	r21
     2e6:	6f 93       	push	r22
     2e8:	7f 93       	push	r23
     2ea:	8f 93       	push	r24
     2ec:	9f 93       	push	r25
     2ee:	af 93       	push	r26
     2f0:	bf 93       	push	r27
     2f2:	ef 93       	push	r30
     2f4:	ff 93       	push	r31
//

/* static */
inline void SoftwareSerial::handle_interrupt()
{
  if (active_object)
     2f6:	80 91 3a 01 	lds	r24, 0x013A
     2fa:	90 91 3b 01 	lds	r25, 0x013B
     2fe:	00 97       	sbiw	r24, 0x00	; 0
     300:	11 f0       	breq	.+4      	; 0x306 <__vector_4+0x32>
  {
    active_object->recv();
     302:	0e 94 d6 00 	call	0x1ac	; 0x1ac <_ZN14SoftwareSerial4recvEv>

#if defined(PCINT1_vect)
ISR(PCINT1_vect)
{
  SoftwareSerial::handle_interrupt();
}
     306:	ff 91       	pop	r31
     308:	ef 91       	pop	r30
     30a:	bf 91       	pop	r27
     30c:	af 91       	pop	r26
     30e:	9f 91       	pop	r25
     310:	8f 91       	pop	r24
     312:	7f 91       	pop	r23
     314:	6f 91       	pop	r22
     316:	5f 91       	pop	r21
     318:	4f 91       	pop	r20
     31a:	3f 91       	pop	r19
     31c:	2f 91       	pop	r18
     31e:	0f 90       	pop	r0
     320:	0f be       	out	0x3f, r0	; 63
     322:	0f 90       	pop	r0
     324:	1f 90       	pop	r1
     326:	18 95       	reti

00000328 <__vector_5>:
#endif

#if defined(PCINT2_vect)
ISR(PCINT2_vect)
     328:	1f 92       	push	r1
     32a:	0f 92       	push	r0
     32c:	0f b6       	in	r0, 0x3f	; 63
     32e:	0f 92       	push	r0
     330:	11 24       	eor	r1, r1
     332:	2f 93       	push	r18
     334:	3f 93       	push	r19
     336:	4f 93       	push	r20
     338:	5f 93       	push	r21
     33a:	6f 93       	push	r22
     33c:	7f 93       	push	r23
     33e:	8f 93       	push	r24
     340:	9f 93       	push	r25
     342:	af 93       	push	r26
     344:	bf 93       	push	r27
     346:	ef 93       	push	r30
     348:	ff 93       	push	r31
//

/* static */
inline void SoftwareSerial::handle_interrupt()
{
  if (active_object)
     34a:	80 91 3a 01 	lds	r24, 0x013A
     34e:	90 91 3b 01 	lds	r25, 0x013B
     352:	00 97       	sbiw	r24, 0x00	; 0
     354:	11 f0       	breq	.+4      	; 0x35a <__vector_5+0x32>
  {
    active_object->recv();
     356:	0e 94 d6 00 	call	0x1ac	; 0x1ac <_ZN14SoftwareSerial4recvEv>

#if defined(PCINT2_vect)
ISR(PCINT2_vect)
{
  SoftwareSerial::handle_interrupt();
}
     35a:	ff 91       	pop	r31
     35c:	ef 91       	pop	r30
     35e:	bf 91       	pop	r27
     360:	af 91       	pop	r26
     362:	9f 91       	pop	r25
     364:	8f 91       	pop	r24
     366:	7f 91       	pop	r23
     368:	6f 91       	pop	r22
     36a:	5f 91       	pop	r21
     36c:	4f 91       	pop	r20
     36e:	3f 91       	pop	r19
     370:	2f 91       	pop	r18
     372:	0f 90       	pop	r0
     374:	0f be       	out	0x3f, r0	; 63
     376:	0f 90       	pop	r0
     378:	1f 90       	pop	r1
     37a:	18 95       	reti

0000037c <_ZN14SoftwareSerial5beginEl>:

//
// Public methods
//

void SoftwareSerial::begin(long speed)
     37c:	cf 92       	push	r12
     37e:	df 92       	push	r13
     380:	ef 92       	push	r14
     382:	ff 92       	push	r15
     384:	0f 93       	push	r16
     386:	1f 93       	push	r17
     388:	cf 93       	push	r28
     38a:	df 93       	push	r29
     38c:	ec 01       	movw	r28, r24
     38e:	7a 01       	movw	r14, r20
     390:	8b 01       	movw	r16, r22
{
  _rx_delay_centering = _rx_delay_intrabit = _rx_delay_stopbit = _tx_delay = 0;
     392:	1a 8e       	std	Y+26, r1	; 0x1a
     394:	19 8e       	std	Y+25, r1	; 0x19
     396:	18 8e       	std	Y+24, r1	; 0x18
     398:	1f 8a       	std	Y+23, r1	; 0x17
     39a:	1e 8a       	std	Y+22, r1	; 0x16
     39c:	1d 8a       	std	Y+21, r1	; 0x15
     39e:	1c 8a       	std	Y+20, r1	; 0x14
     3a0:	1b 8a       	std	Y+19, r1	; 0x13
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	30 e0       	ldi	r19, 0x00	; 0

  for (unsigned i=0; i<sizeof(table)/sizeof(table[0]); ++i)
  {
    long baud = pgm_read_dword(&table[i].baud);
     3a6:	69 01       	movw	r12, r18
     3a8:	cc 0c       	add	r12, r12
     3aa:	dd 1c       	adc	r13, r13
     3ac:	c2 0e       	add	r12, r18
     3ae:	d3 1e       	adc	r13, r19
     3b0:	b6 01       	movw	r22, r12
     3b2:	66 0f       	add	r22, r22
     3b4:	77 1f       	adc	r23, r23
     3b6:	66 0f       	add	r22, r22
     3b8:	77 1f       	adc	r23, r23
     3ba:	ab 01       	movw	r20, r22
     3bc:	48 59       	subi	r20, 0x98	; 152
     3be:	5f 4f       	sbci	r21, 0xFF	; 255
     3c0:	fa 01       	movw	r30, r20
     3c2:	85 91       	lpm	r24, Z+
     3c4:	95 91       	lpm	r25, Z+
     3c6:	a5 91       	lpm	r26, Z+
     3c8:	b4 91       	lpm	r27, Z+
    if (baud == speed)
     3ca:	8e 15       	cp	r24, r14
     3cc:	9f 05       	cpc	r25, r15
     3ce:	a0 07       	cpc	r26, r16
     3d0:	b1 07       	cpc	r27, r17
     3d2:	e9 f4       	brne	.+58     	; 0x40e <_ZN14SoftwareSerial5beginEl+0x92>
    {
      _rx_delay_centering = pgm_read_word(&table[i].rx_delay_centering);
     3d4:	fb 01       	movw	r30, r22
     3d6:	e4 59       	subi	r30, 0x94	; 148
     3d8:	ff 4f       	sbci	r31, 0xFF	; 255
     3da:	85 91       	lpm	r24, Z+
     3dc:	94 91       	lpm	r25, Z+
     3de:	9c 8b       	std	Y+20, r25	; 0x14
     3e0:	8b 8b       	std	Y+19, r24	; 0x13
      _rx_delay_intrabit = pgm_read_word(&table[i].rx_delay_intrabit);
     3e2:	fb 01       	movw	r30, r22
     3e4:	e2 59       	subi	r30, 0x92	; 146
     3e6:	ff 4f       	sbci	r31, 0xFF	; 255
     3e8:	85 91       	lpm	r24, Z+
     3ea:	94 91       	lpm	r25, Z+
     3ec:	9e 8b       	std	Y+22, r25	; 0x16
     3ee:	8d 8b       	std	Y+21, r24	; 0x15
      _rx_delay_stopbit = pgm_read_word(&table[i].rx_delay_stopbit);
     3f0:	fb 01       	movw	r30, r22
     3f2:	e0 59       	subi	r30, 0x90	; 144
     3f4:	ff 4f       	sbci	r31, 0xFF	; 255
     3f6:	85 91       	lpm	r24, Z+
     3f8:	94 91       	lpm	r25, Z+
     3fa:	98 8f       	std	Y+24, r25	; 0x18
     3fc:	8f 8b       	std	Y+23, r24	; 0x17
      _tx_delay = pgm_read_word(&table[i].tx_delay);
     3fe:	fb 01       	movw	r30, r22
     400:	ee 58       	subi	r30, 0x8E	; 142
     402:	ff 4f       	sbci	r31, 0xFF	; 255
     404:	85 91       	lpm	r24, Z+
     406:	94 91       	lpm	r25, Z+
     408:	9a 8f       	std	Y+26, r25	; 0x1a
     40a:	89 8f       	std	Y+25, r24	; 0x19
     40c:	06 c0       	rjmp	.+12     	; 0x41a <_ZN14SoftwareSerial5beginEl+0x9e>

void SoftwareSerial::begin(long speed)
{
  _rx_delay_centering = _rx_delay_intrabit = _rx_delay_stopbit = _tx_delay = 0;

  for (unsigned i=0; i<sizeof(table)/sizeof(table[0]); ++i)
     40e:	2f 5f       	subi	r18, 0xFF	; 255
     410:	3f 4f       	sbci	r19, 0xFF	; 255
     412:	2c 30       	cpi	r18, 0x0C	; 12
     414:	31 05       	cpc	r19, r1
     416:	09 f0       	breq	.+2      	; 0x41a <_ZN14SoftwareSerial5beginEl+0x9e>
     418:	c6 cf       	rjmp	.-116    	; 0x3a6 <_ZN14SoftwareSerial5beginEl+0x2a>
      break;
    }
  }

  // Set up RX interrupts, but only if we have a valid RX baud rate
  if (_rx_delay_stopbit)
     41a:	8f 89       	ldd	r24, Y+23	; 0x17
     41c:	98 8d       	ldd	r25, Y+24	; 0x18
     41e:	89 2b       	or	r24, r25
     420:	09 f4       	brne	.+2      	; 0x424 <_ZN14SoftwareSerial5beginEl+0xa8>
     422:	49 c0       	rjmp	.+146    	; 0x4b6 <_ZN14SoftwareSerial5beginEl+0x13a>
  {
    if (digitalPinToPCICR(_receivePin))
     424:	4c 85       	ldd	r20, Y+12	; 0x0c
     426:	46 31       	cpi	r20, 0x16	; 22
     428:	08 f0       	brcs	.+2      	; 0x42c <_ZN14SoftwareSerial5beginEl+0xb0>
     42a:	3d c0       	rjmp	.+122    	; 0x4a6 <_ZN14SoftwareSerial5beginEl+0x12a>
    {
      *digitalPinToPCICR(_receivePin) |= _BV(digitalPinToPCICRbit(_receivePin));
     42c:	90 91 68 00 	lds	r25, 0x0068
     430:	48 30       	cpi	r20, 0x08	; 8
     432:	10 f4       	brcc	.+4      	; 0x438 <_ZN14SoftwareSerial5beginEl+0xbc>
     434:	84 e0       	ldi	r24, 0x04	; 4
     436:	05 c0       	rjmp	.+10     	; 0x442 <_ZN14SoftwareSerial5beginEl+0xc6>
     438:	4e 30       	cpi	r20, 0x0E	; 14
     43a:	10 f0       	brcs	.+4      	; 0x440 <_ZN14SoftwareSerial5beginEl+0xc4>
     43c:	82 e0       	ldi	r24, 0x02	; 2
     43e:	01 c0       	rjmp	.+2      	; 0x442 <_ZN14SoftwareSerial5beginEl+0xc6>
     440:	81 e0       	ldi	r24, 0x01	; 1
     442:	89 2b       	or	r24, r25
     444:	80 93 68 00 	sts	0x0068, r24
      *digitalPinToPCMSK(_receivePin) |= _BV(digitalPinToPCMSKbit(_receivePin));
     448:	48 30       	cpi	r20, 0x08	; 8
     44a:	28 f4       	brcc	.+10     	; 0x456 <_ZN14SoftwareSerial5beginEl+0xda>
     44c:	ed e6       	ldi	r30, 0x6D	; 109
     44e:	f0 e0       	ldi	r31, 0x00	; 0
     450:	ad e6       	ldi	r26, 0x6D	; 109
     452:	b0 e0       	ldi	r27, 0x00	; 0
     454:	0b c0       	rjmp	.+22     	; 0x46c <_ZN14SoftwareSerial5beginEl+0xf0>
     456:	4e 30       	cpi	r20, 0x0E	; 14
     458:	28 f0       	brcs	.+10     	; 0x464 <_ZN14SoftwareSerial5beginEl+0xe8>
     45a:	ec e6       	ldi	r30, 0x6C	; 108
     45c:	f0 e0       	ldi	r31, 0x00	; 0
     45e:	ac e6       	ldi	r26, 0x6C	; 108
     460:	b0 e0       	ldi	r27, 0x00	; 0
     462:	04 c0       	rjmp	.+8      	; 0x46c <_ZN14SoftwareSerial5beginEl+0xf0>
     464:	eb e6       	ldi	r30, 0x6B	; 107
     466:	f0 e0       	ldi	r31, 0x00	; 0
     468:	ab e6       	ldi	r26, 0x6B	; 107
     46a:	b0 e0       	ldi	r27, 0x00	; 0
     46c:	50 81       	ld	r21, Z
     46e:	48 30       	cpi	r20, 0x08	; 8
     470:	40 f4       	brcc	.+16     	; 0x482 <_ZN14SoftwareSerial5beginEl+0x106>
     472:	81 e0       	ldi	r24, 0x01	; 1
     474:	90 e0       	ldi	r25, 0x00	; 0
     476:	02 c0       	rjmp	.+4      	; 0x47c <_ZN14SoftwareSerial5beginEl+0x100>
     478:	88 0f       	add	r24, r24
     47a:	99 1f       	adc	r25, r25
     47c:	4a 95       	dec	r20
     47e:	e2 f7       	brpl	.-8      	; 0x478 <_ZN14SoftwareSerial5beginEl+0xfc>
     480:	10 c0       	rjmp	.+32     	; 0x4a2 <_ZN14SoftwareSerial5beginEl+0x126>
     482:	24 2f       	mov	r18, r20
     484:	30 e0       	ldi	r19, 0x00	; 0
     486:	4e 30       	cpi	r20, 0x0E	; 14
     488:	18 f4       	brcc	.+6      	; 0x490 <_ZN14SoftwareSerial5beginEl+0x114>
     48a:	28 50       	subi	r18, 0x08	; 8
     48c:	30 40       	sbci	r19, 0x00	; 0
     48e:	02 c0       	rjmp	.+4      	; 0x494 <_ZN14SoftwareSerial5beginEl+0x118>
     490:	2e 50       	subi	r18, 0x0E	; 14
     492:	30 40       	sbci	r19, 0x00	; 0
     494:	81 e0       	ldi	r24, 0x01	; 1
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	02 c0       	rjmp	.+4      	; 0x49e <_ZN14SoftwareSerial5beginEl+0x122>
     49a:	88 0f       	add	r24, r24
     49c:	99 1f       	adc	r25, r25
     49e:	2a 95       	dec	r18
     4a0:	e2 f7       	brpl	.-8      	; 0x49a <_ZN14SoftwareSerial5beginEl+0x11e>
     4a2:	85 2b       	or	r24, r21
     4a4:	8c 93       	st	X, r24
    }
    tunedDelay(_tx_delay); // if we were low this establishes the end
     4a6:	89 8d       	ldd	r24, Y+25	; 0x19
     4a8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     4aa:	20 e0       	ldi	r18, 0x00	; 0
     4ac:	01 97       	sbiw	r24, 0x01	; 1
     4ae:	2f ef       	ldi	r18, 0xFF	; 255
     4b0:	8f 3f       	cpi	r24, 0xFF	; 255
     4b2:	92 07       	cpc	r25, r18
     4b4:	d9 f7       	brne	.-10     	; 0x4ac <_ZN14SoftwareSerial5beginEl+0x130>

// This function sets the current object as the "listening"
// one and returns true if it replaces another 
bool SoftwareSerial::listen()
{
  if (active_object != this)
     4b6:	80 91 3a 01 	lds	r24, 0x013A
     4ba:	90 91 3b 01 	lds	r25, 0x013B
     4be:	8c 17       	cp	r24, r28
     4c0:	9d 07       	cpc	r25, r29
     4c2:	81 f0       	breq	.+32     	; 0x4e4 <_ZN14SoftwareSerial5beginEl+0x168>
  {
    _buffer_overflow = false;
     4c4:	8b 8d       	ldd	r24, Y+27	; 0x1b
     4c6:	8e 7f       	andi	r24, 0xFE	; 254
     4c8:	8b 8f       	std	Y+27, r24	; 0x1b
    uint8_t oldSREG = SREG;
     4ca:	9f b7       	in	r25, 0x3f	; 63
    cli();
     4cc:	f8 94       	cli
    _receive_buffer_head = _receive_buffer_tail = 0;
     4ce:	10 92 7c 01 	sts	0x017C, r1
     4d2:	80 91 7c 01 	lds	r24, 0x017C
     4d6:	80 93 7d 01 	sts	0x017D, r24
    active_object = this;
     4da:	d0 93 3b 01 	sts	0x013B, r29
     4de:	c0 93 3a 01 	sts	0x013A, r28
    SREG = oldSREG;
     4e2:	9f bf       	out	0x3f, r25	; 63
  pinMode(_DEBUG_PIN1, OUTPUT);
  pinMode(_DEBUG_PIN2, OUTPUT);
#endif

  listen();
}
     4e4:	df 91       	pop	r29
     4e6:	cf 91       	pop	r28
     4e8:	1f 91       	pop	r17
     4ea:	0f 91       	pop	r16
     4ec:	ff 90       	pop	r15
     4ee:	ef 90       	pop	r14
     4f0:	df 90       	pop	r13
     4f2:	cf 90       	pop	r12
     4f4:	08 95       	ret

000004f6 <_ZN14SoftwareSerial3endEv>:

void SoftwareSerial::end()
{
  if (digitalPinToPCMSK(_receivePin))
     4f6:	fc 01       	movw	r30, r24
     4f8:	44 85       	ldd	r20, Z+12	; 0x0c
     4fa:	46 31       	cpi	r20, 0x16	; 22
     4fc:	80 f5       	brcc	.+96     	; 0x55e <_ZN14SoftwareSerial3endEv+0x68>
    *digitalPinToPCMSK(_receivePin) &= ~_BV(digitalPinToPCMSKbit(_receivePin));
     4fe:	48 30       	cpi	r20, 0x08	; 8
     500:	28 f4       	brcc	.+10     	; 0x50c <_ZN14SoftwareSerial3endEv+0x16>
     502:	ed e6       	ldi	r30, 0x6D	; 109
     504:	f0 e0       	ldi	r31, 0x00	; 0
     506:	ad e6       	ldi	r26, 0x6D	; 109
     508:	b0 e0       	ldi	r27, 0x00	; 0
     50a:	0b c0       	rjmp	.+22     	; 0x522 <_ZN14SoftwareSerial3endEv+0x2c>
     50c:	4e 30       	cpi	r20, 0x0E	; 14
     50e:	28 f4       	brcc	.+10     	; 0x51a <_ZN14SoftwareSerial3endEv+0x24>
     510:	eb e6       	ldi	r30, 0x6B	; 107
     512:	f0 e0       	ldi	r31, 0x00	; 0
     514:	ab e6       	ldi	r26, 0x6B	; 107
     516:	b0 e0       	ldi	r27, 0x00	; 0
     518:	04 c0       	rjmp	.+8      	; 0x522 <_ZN14SoftwareSerial3endEv+0x2c>
     51a:	ec e6       	ldi	r30, 0x6C	; 108
     51c:	f0 e0       	ldi	r31, 0x00	; 0
     51e:	ac e6       	ldi	r26, 0x6C	; 108
     520:	b0 e0       	ldi	r27, 0x00	; 0
     522:	50 81       	ld	r21, Z
     524:	48 30       	cpi	r20, 0x08	; 8
     526:	40 f4       	brcc	.+16     	; 0x538 <_ZN14SoftwareSerial3endEv+0x42>
     528:	81 e0       	ldi	r24, 0x01	; 1
     52a:	90 e0       	ldi	r25, 0x00	; 0
     52c:	02 c0       	rjmp	.+4      	; 0x532 <_ZN14SoftwareSerial3endEv+0x3c>
     52e:	88 0f       	add	r24, r24
     530:	99 1f       	adc	r25, r25
     532:	4a 95       	dec	r20
     534:	e2 f7       	brpl	.-8      	; 0x52e <_ZN14SoftwareSerial3endEv+0x38>
     536:	10 c0       	rjmp	.+32     	; 0x558 <_ZN14SoftwareSerial3endEv+0x62>
     538:	24 2f       	mov	r18, r20
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	4e 30       	cpi	r20, 0x0E	; 14
     53e:	18 f4       	brcc	.+6      	; 0x546 <_ZN14SoftwareSerial3endEv+0x50>
     540:	28 50       	subi	r18, 0x08	; 8
     542:	30 40       	sbci	r19, 0x00	; 0
     544:	02 c0       	rjmp	.+4      	; 0x54a <_ZN14SoftwareSerial3endEv+0x54>
     546:	2e 50       	subi	r18, 0x0E	; 14
     548:	30 40       	sbci	r19, 0x00	; 0
     54a:	81 e0       	ldi	r24, 0x01	; 1
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	02 c0       	rjmp	.+4      	; 0x554 <_ZN14SoftwareSerial3endEv+0x5e>
     550:	88 0f       	add	r24, r24
     552:	99 1f       	adc	r25, r25
     554:	2a 95       	dec	r18
     556:	e2 f7       	brpl	.-8      	; 0x550 <_ZN14SoftwareSerial3endEv+0x5a>
     558:	80 95       	com	r24
     55a:	85 23       	and	r24, r21
     55c:	8c 93       	st	X, r24
     55e:	08 95       	ret

00000560 <_ZN14SoftwareSerialD1Ev>:
}

//
// Destructor
//
SoftwareSerial::~SoftwareSerial()
     560:	fc 01       	movw	r30, r24
     562:	8e e1       	ldi	r24, 0x1E	; 30
     564:	91 e0       	ldi	r25, 0x01	; 1
     566:	91 83       	std	Z+1, r25	; 0x01
     568:	80 83       	st	Z, r24
{
  end();
     56a:	cf 01       	movw	r24, r30
     56c:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <_ZN14SoftwareSerial3endEv>
}
     570:	08 95       	ret

00000572 <_ZN14SoftwareSerial4readEv>:


// Read data from buffer
int SoftwareSerial::read()
{
  if (!isListening())
     572:	20 91 3a 01 	lds	r18, 0x013A
     576:	30 91 3b 01 	lds	r19, 0x013B
     57a:	28 17       	cp	r18, r24
     57c:	39 07       	cpc	r19, r25
     57e:	31 f4       	brne	.+12     	; 0x58c <_ZN14SoftwareSerial4readEv+0x1a>
    return -1;

  // Empty buffer?
  if (_receive_buffer_head == _receive_buffer_tail)
     580:	90 91 7d 01 	lds	r25, 0x017D
     584:	80 91 7c 01 	lds	r24, 0x017C
     588:	98 17       	cp	r25, r24
     58a:	19 f4       	brne	.+6      	; 0x592 <_ZN14SoftwareSerial4readEv+0x20>
     58c:	2f ef       	ldi	r18, 0xFF	; 255
     58e:	3f ef       	ldi	r19, 0xFF	; 255
     590:	0f c0       	rjmp	.+30     	; 0x5b0 <_ZN14SoftwareSerial4readEv+0x3e>
    return -1;

  // Read from "head"
  uint8_t d = _receive_buffer[_receive_buffer_head]; // grab next byte
     592:	e0 91 7d 01 	lds	r30, 0x017D
     596:	f0 e0       	ldi	r31, 0x00	; 0
     598:	e4 5c       	subi	r30, 0xC4	; 196
     59a:	fe 4f       	sbci	r31, 0xFE	; 254
     59c:	20 81       	ld	r18, Z
  _receive_buffer_head = (_receive_buffer_head + 1) % _SS_MAX_RX_BUFF;
     59e:	80 91 7d 01 	lds	r24, 0x017D
     5a2:	90 e0       	ldi	r25, 0x00	; 0
     5a4:	01 96       	adiw	r24, 0x01	; 1
     5a6:	8f 73       	andi	r24, 0x3F	; 63
     5a8:	90 70       	andi	r25, 0x00	; 0
     5aa:	80 93 7d 01 	sts	0x017D, r24
  return d;
     5ae:	30 e0       	ldi	r19, 0x00	; 0
}
     5b0:	c9 01       	movw	r24, r18
     5b2:	08 95       	ret

000005b4 <_ZN14SoftwareSerial9availableEv>:

int SoftwareSerial::available()
{
  if (!isListening())
     5b4:	20 91 3a 01 	lds	r18, 0x013A
     5b8:	30 91 3b 01 	lds	r19, 0x013B
     5bc:	28 17       	cp	r18, r24
     5be:	39 07       	cpc	r19, r25
     5c0:	19 f0       	breq	.+6      	; 0x5c8 <_ZN14SoftwareSerial9availableEv+0x14>
     5c2:	20 e0       	ldi	r18, 0x00	; 0
     5c4:	30 e0       	ldi	r19, 0x00	; 0
     5c6:	0e c0       	rjmp	.+28     	; 0x5e4 <_ZN14SoftwareSerial9availableEv+0x30>
    return 0;

  return (_receive_buffer_tail + _SS_MAX_RX_BUFF - _receive_buffer_head) % _SS_MAX_RX_BUFF;
     5c8:	80 91 7c 01 	lds	r24, 0x017C
     5cc:	20 91 7d 01 	lds	r18, 0x017D
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	80 5c       	subi	r24, 0xC0	; 192
     5d4:	9f 4f       	sbci	r25, 0xFF	; 255
     5d6:	82 1b       	sub	r24, r18
     5d8:	91 09       	sbc	r25, r1
     5da:	60 e4       	ldi	r22, 0x40	; 64
     5dc:	70 e0       	ldi	r23, 0x00	; 0
     5de:	0e 94 d5 08 	call	0x11aa	; 0x11aa <__divmodhi4>
     5e2:	9c 01       	movw	r18, r24
}
     5e4:	c9 01       	movw	r24, r18
     5e6:	08 95       	ret

000005e8 <_ZN14SoftwareSerial5writeEh>:

size_t SoftwareSerial::write(uint8_t b)
     5e8:	0f 93       	push	r16
     5ea:	1f 93       	push	r17
     5ec:	dc 01       	movw	r26, r24
{
  if (_tx_delay == 0) {
     5ee:	59 96       	adiw	r26, 0x19	; 25
     5f0:	8d 91       	ld	r24, X+
     5f2:	9c 91       	ld	r25, X
     5f4:	5a 97       	sbiw	r26, 0x1a	; 26
     5f6:	89 2b       	or	r24, r25
     5f8:	49 f4       	brne	.+18     	; 0x60c <_ZN14SoftwareSerial5writeEh+0x24>
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
     5fa:	81 e0       	ldi	r24, 0x01	; 1
     5fc:	90 e0       	ldi	r25, 0x00	; 0
     5fe:	13 96       	adiw	r26, 0x03	; 3
     600:	9c 93       	st	X, r25
     602:	8e 93       	st	-X, r24
     604:	12 97       	sbiw	r26, 0x02	; 2
     606:	20 e0       	ldi	r18, 0x00	; 0
     608:	30 e0       	ldi	r19, 0x00	; 0
     60a:	97 c0       	rjmp	.+302    	; 0x73a <_ZN14SoftwareSerial5writeEh+0x152>
    setWriteError();
    return 0;
  }

  uint8_t oldSREG = SREG;
     60c:	0f b7       	in	r16, 0x3f	; 63
  cli();  // turn off interrupts for a clean txmit
     60e:	f8 94       	cli

  // Write the start bit
  tx_pin_write(_inverse_logic ? HIGH : LOW);
     610:	5b 96       	adiw	r26, 0x1b	; 27
     612:	8c 91       	ld	r24, X
     614:	5b 97       	sbiw	r26, 0x1b	; 27
     616:	51 96       	adiw	r26, 0x11	; 17
     618:	ed 91       	ld	r30, X+
     61a:	fc 91       	ld	r31, X
     61c:	52 97       	sbiw	r26, 0x12	; 18
     61e:	50 96       	adiw	r26, 0x10	; 16
     620:	2c 91       	ld	r18, X
     622:	50 97       	sbiw	r26, 0x10	; 16
     624:	81 ff       	sbrs	r24, 1
     626:	8d c0       	rjmp	.+282    	; 0x742 <_ZN14SoftwareSerial5writeEh+0x15a>
void SoftwareSerial::tx_pin_write(uint8_t pin_state)
{
  if (pin_state == LOW)
    *_transmitPortRegister &= ~_transmitBitMask;
  else
    *_transmitPortRegister |= _transmitBitMask;
     628:	80 81       	ld	r24, Z
     62a:	82 2b       	or	r24, r18
     62c:	80 83       	st	Z, r24
  uint8_t oldSREG = SREG;
  cli();  // turn off interrupts for a clean txmit

  // Write the start bit
  tx_pin_write(_inverse_logic ? HIGH : LOW);
  tunedDelay(_tx_delay + XMIT_START_ADJUSTMENT);
     62e:	59 96       	adiw	r26, 0x19	; 25
     630:	8d 91       	ld	r24, X+
     632:	9c 91       	ld	r25, X
     634:	5a 97       	sbiw	r26, 0x1a	; 26
     636:	05 96       	adiw	r24, 0x05	; 5
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     638:	20 e0       	ldi	r18, 0x00	; 0
     63a:	01 97       	sbiw	r24, 0x01	; 1
     63c:	2f ef       	ldi	r18, 0xFF	; 255
     63e:	8f 3f       	cpi	r24, 0xFF	; 255
     640:	92 07       	cpc	r25, r18
     642:	d9 f7       	brne	.-10     	; 0x63a <_ZN14SoftwareSerial5writeEh+0x52>
  // Write the start bit
  tx_pin_write(_inverse_logic ? HIGH : LOW);
  tunedDelay(_tx_delay + XMIT_START_ADJUSTMENT);

  // Write each of the 8 bits
  if (_inverse_logic)
     644:	5b 96       	adiw	r26, 0x1b	; 27
     646:	8c 91       	ld	r24, X
     648:	5b 97       	sbiw	r26, 0x1b	; 27
     64a:	81 ff       	sbrs	r24, 1
     64c:	35 c0       	rjmp	.+106    	; 0x6b8 <_ZN14SoftwareSerial5writeEh+0xd0>
     64e:	31 e0       	ldi	r19, 0x01	; 1
     650:	40 e0       	ldi	r20, 0x00	; 0
     652:	50 e0       	ldi	r21, 0x00	; 0
  {
    for (byte mask = 0x01; mask; mask <<= 1)
    {
      if (b & mask) // choose bit
     654:	70 e0       	ldi	r23, 0x00	; 0
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     656:	10 e0       	ldi	r17, 0x00	; 0
  // Write each of the 8 bits
  if (_inverse_logic)
  {
    for (byte mask = 0x01; mask; mask <<= 1)
    {
      if (b & mask) // choose bit
     658:	83 2f       	mov	r24, r19
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	86 23       	and	r24, r22
     65e:	97 23       	and	r25, r23
     660:	51 96       	adiw	r26, 0x11	; 17
     662:	ed 91       	ld	r30, X+
     664:	fc 91       	ld	r31, X
     666:	52 97       	sbiw	r26, 0x12	; 18
     668:	50 96       	adiw	r26, 0x10	; 16
     66a:	2c 91       	ld	r18, X
     66c:	50 97       	sbiw	r26, 0x10	; 16
     66e:	89 2b       	or	r24, r25
     670:	29 f0       	breq	.+10     	; 0x67c <_ZN14SoftwareSerial5writeEh+0x94>
}

void SoftwareSerial::tx_pin_write(uint8_t pin_state)
{
  if (pin_state == LOW)
    *_transmitPortRegister &= ~_transmitBitMask;
     672:	80 81       	ld	r24, Z
     674:	20 95       	com	r18
     676:	28 23       	and	r18, r24
     678:	20 83       	st	Z, r18
     67a:	03 c0       	rjmp	.+6      	; 0x682 <_ZN14SoftwareSerial5writeEh+0x9a>
  else
    *_transmitPortRegister |= _transmitBitMask;
     67c:	80 81       	ld	r24, Z
     67e:	82 2b       	or	r24, r18
     680:	80 83       	st	Z, r24
      if (b & mask) // choose bit
        tx_pin_write(LOW); // send 1
      else
        tx_pin_write(HIGH); // send 0
    
      tunedDelay(_tx_delay);
     682:	59 96       	adiw	r26, 0x19	; 25
     684:	8d 91       	ld	r24, X+
     686:	9c 91       	ld	r25, X
     688:	5a 97       	sbiw	r26, 0x1a	; 26
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     68a:	21 2f       	mov	r18, r17
     68c:	01 97       	sbiw	r24, 0x01	; 1
     68e:	2f ef       	ldi	r18, 0xFF	; 255
     690:	8f 3f       	cpi	r24, 0xFF	; 255
     692:	92 07       	cpc	r25, r18
     694:	d9 f7       	brne	.-10     	; 0x68c <_ZN14SoftwareSerial5writeEh+0xa4>
  tunedDelay(_tx_delay + XMIT_START_ADJUSTMENT);

  // Write each of the 8 bits
  if (_inverse_logic)
  {
    for (byte mask = 0x01; mask; mask <<= 1)
     696:	33 0f       	add	r19, r19
     698:	4f 5f       	subi	r20, 0xFF	; 255
     69a:	5f 4f       	sbci	r21, 0xFF	; 255
     69c:	48 30       	cpi	r20, 0x08	; 8
     69e:	51 05       	cpc	r21, r1
     6a0:	d9 f6       	brne	.-74     	; 0x658 <_ZN14SoftwareSerial5writeEh+0x70>
}

void SoftwareSerial::tx_pin_write(uint8_t pin_state)
{
  if (pin_state == LOW)
    *_transmitPortRegister &= ~_transmitBitMask;
     6a2:	51 96       	adiw	r26, 0x11	; 17
     6a4:	ed 91       	ld	r30, X+
     6a6:	fc 91       	ld	r31, X
     6a8:	52 97       	sbiw	r26, 0x12	; 18
     6aa:	90 81       	ld	r25, Z
     6ac:	50 96       	adiw	r26, 0x10	; 16
     6ae:	8c 91       	ld	r24, X
     6b0:	50 97       	sbiw	r26, 0x10	; 16
     6b2:	80 95       	com	r24
     6b4:	89 23       	and	r24, r25
     6b6:	33 c0       	rjmp	.+102    	; 0x71e <_ZN14SoftwareSerial5writeEh+0x136>
     6b8:	31 e0       	ldi	r19, 0x01	; 1
     6ba:	40 e0       	ldi	r20, 0x00	; 0
     6bc:	50 e0       	ldi	r21, 0x00	; 0
  }
  else
  {
    for (byte mask = 0x01; mask; mask <<= 1)
    {
      if (b & mask) // choose bit
     6be:	70 e0       	ldi	r23, 0x00	; 0
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     6c0:	10 e0       	ldi	r17, 0x00	; 0
  }
  else
  {
    for (byte mask = 0x01; mask; mask <<= 1)
    {
      if (b & mask) // choose bit
     6c2:	83 2f       	mov	r24, r19
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	86 23       	and	r24, r22
     6c8:	97 23       	and	r25, r23
     6ca:	51 96       	adiw	r26, 0x11	; 17
     6cc:	ed 91       	ld	r30, X+
     6ce:	fc 91       	ld	r31, X
     6d0:	52 97       	sbiw	r26, 0x12	; 18
     6d2:	50 96       	adiw	r26, 0x10	; 16
     6d4:	2c 91       	ld	r18, X
     6d6:	50 97       	sbiw	r26, 0x10	; 16
     6d8:	89 2b       	or	r24, r25
     6da:	21 f0       	breq	.+8      	; 0x6e4 <_ZN14SoftwareSerial5writeEh+0xfc>
void SoftwareSerial::tx_pin_write(uint8_t pin_state)
{
  if (pin_state == LOW)
    *_transmitPortRegister &= ~_transmitBitMask;
  else
    *_transmitPortRegister |= _transmitBitMask;
     6dc:	80 81       	ld	r24, Z
     6de:	82 2b       	or	r24, r18
     6e0:	80 83       	st	Z, r24
     6e2:	04 c0       	rjmp	.+8      	; 0x6ec <_ZN14SoftwareSerial5writeEh+0x104>
}

void SoftwareSerial::tx_pin_write(uint8_t pin_state)
{
  if (pin_state == LOW)
    *_transmitPortRegister &= ~_transmitBitMask;
     6e4:	80 81       	ld	r24, Z
     6e6:	20 95       	com	r18
     6e8:	28 23       	and	r18, r24
     6ea:	20 83       	st	Z, r18
      if (b & mask) // choose bit
        tx_pin_write(HIGH); // send 1
      else
        tx_pin_write(LOW); // send 0
    
      tunedDelay(_tx_delay);
     6ec:	59 96       	adiw	r26, 0x19	; 25
     6ee:	8d 91       	ld	r24, X+
     6f0:	9c 91       	ld	r25, X
     6f2:	5a 97       	sbiw	r26, 0x1a	; 26
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     6f4:	21 2f       	mov	r18, r17
     6f6:	01 97       	sbiw	r24, 0x01	; 1
     6f8:	2f ef       	ldi	r18, 0xFF	; 255
     6fa:	8f 3f       	cpi	r24, 0xFF	; 255
     6fc:	92 07       	cpc	r25, r18
     6fe:	d9 f7       	brne	.-10     	; 0x6f6 <_ZN14SoftwareSerial5writeEh+0x10e>

    tx_pin_write(LOW); // restore pin to natural state
  }
  else
  {
    for (byte mask = 0x01; mask; mask <<= 1)
     700:	33 0f       	add	r19, r19
     702:	4f 5f       	subi	r20, 0xFF	; 255
     704:	5f 4f       	sbci	r21, 0xFF	; 255
     706:	48 30       	cpi	r20, 0x08	; 8
     708:	51 05       	cpc	r21, r1
     70a:	d9 f6       	brne	.-74     	; 0x6c2 <_ZN14SoftwareSerial5writeEh+0xda>
void SoftwareSerial::tx_pin_write(uint8_t pin_state)
{
  if (pin_state == LOW)
    *_transmitPortRegister &= ~_transmitBitMask;
  else
    *_transmitPortRegister |= _transmitBitMask;
     70c:	51 96       	adiw	r26, 0x11	; 17
     70e:	ed 91       	ld	r30, X+
     710:	fc 91       	ld	r31, X
     712:	52 97       	sbiw	r26, 0x12	; 18
     714:	80 81       	ld	r24, Z
     716:	50 96       	adiw	r26, 0x10	; 16
     718:	9c 91       	ld	r25, X
     71a:	50 97       	sbiw	r26, 0x10	; 16
     71c:	89 2b       	or	r24, r25
     71e:	80 83       	st	Z, r24
    }

    tx_pin_write(HIGH); // restore pin to natural state
  }

  SREG = oldSREG; // turn interrupts back on
     720:	0f bf       	out	0x3f, r16	; 63
  tunedDelay(_tx_delay);
     722:	59 96       	adiw	r26, 0x19	; 25
     724:	8d 91       	ld	r24, X+
     726:	9c 91       	ld	r25, X
     728:	5a 97       	sbiw	r26, 0x1a	; 26
    "cpi %A0, 0xFF \n\t"
    "cpc %B0, %1 \n\t"
    "brne .-10 \n\t"
    : "+r" (delay), "+a" (tmp)
    : "0" (delay)
    );
     72a:	20 e0       	ldi	r18, 0x00	; 0
     72c:	01 97       	sbiw	r24, 0x01	; 1
     72e:	2f ef       	ldi	r18, 0xFF	; 255
     730:	8f 3f       	cpi	r24, 0xFF	; 255
     732:	92 07       	cpc	r25, r18
     734:	d9 f7       	brne	.-10     	; 0x72c <_ZN14SoftwareSerial5writeEh+0x144>
     736:	21 e0       	ldi	r18, 0x01	; 1
     738:	30 e0       	ldi	r19, 0x00	; 0

  SREG = oldSREG; // turn interrupts back on
  tunedDelay(_tx_delay);
  
  return 1;
}
     73a:	c9 01       	movw	r24, r18
     73c:	1f 91       	pop	r17
     73e:	0f 91       	pop	r16
     740:	08 95       	ret
}

void SoftwareSerial::tx_pin_write(uint8_t pin_state)
{
  if (pin_state == LOW)
    *_transmitPortRegister &= ~_transmitBitMask;
     742:	80 81       	ld	r24, Z
     744:	20 95       	com	r18
     746:	28 23       	and	r18, r24
     748:	20 83       	st	Z, r18
     74a:	71 cf       	rjmp	.-286    	; 0x62e <_ZN14SoftwareSerial5writeEh+0x46>

0000074c <_ZN14SoftwareSerial5flushEv>:
  return 1;
}

void SoftwareSerial::flush()
{
  if (!isListening())
     74c:	20 91 3a 01 	lds	r18, 0x013A
     750:	30 91 3b 01 	lds	r19, 0x013B
     754:	28 17       	cp	r18, r24
     756:	39 07       	cpc	r19, r25
     758:	49 f4       	brne	.+18     	; 0x76c <_ZN14SoftwareSerial5flushEv+0x20>
    return;

  uint8_t oldSREG = SREG;
     75a:	9f b7       	in	r25, 0x3f	; 63
  cli();
     75c:	f8 94       	cli
  _receive_buffer_head = _receive_buffer_tail = 0;
     75e:	10 92 7c 01 	sts	0x017C, r1
     762:	80 91 7c 01 	lds	r24, 0x017C
     766:	80 93 7d 01 	sts	0x017D, r24
  SREG = oldSREG;
     76a:	9f bf       	out	0x3f, r25	; 63
     76c:	08 95       	ret

0000076e <_ZN14SoftwareSerial4peekEv>:
}

int SoftwareSerial::peek()
{
  if (!isListening())
     76e:	20 91 3a 01 	lds	r18, 0x013A
     772:	30 91 3b 01 	lds	r19, 0x013B
     776:	28 17       	cp	r18, r24
     778:	39 07       	cpc	r19, r25
     77a:	31 f4       	brne	.+12     	; 0x788 <_ZN14SoftwareSerial4peekEv+0x1a>
    return -1;

  // Empty buffer?
  if (_receive_buffer_head == _receive_buffer_tail)
     77c:	90 91 7d 01 	lds	r25, 0x017D
     780:	80 91 7c 01 	lds	r24, 0x017C
     784:	98 17       	cp	r25, r24
     786:	19 f4       	brne	.+6      	; 0x78e <_ZN14SoftwareSerial4peekEv+0x20>
     788:	2f ef       	ldi	r18, 0xFF	; 255
     78a:	3f ef       	ldi	r19, 0xFF	; 255
     78c:	0a c0       	rjmp	.+20     	; 0x7a2 <_ZN14SoftwareSerial4peekEv+0x34>
    return -1;

  // Read from "head"
  return _receive_buffer[_receive_buffer_head];
     78e:	e0 91 7d 01 	lds	r30, 0x017D
     792:	f0 e0       	ldi	r31, 0x00	; 0
     794:	e4 5c       	subi	r30, 0xC4	; 196
     796:	fe 4f       	sbci	r31, 0xFE	; 254
     798:	80 81       	ld	r24, Z
     79a:	28 2f       	mov	r18, r24
     79c:	33 27       	eor	r19, r19
     79e:	27 fd       	sbrc	r18, 7
     7a0:	30 95       	com	r19
}
     7a2:	c9 01       	movw	r24, r18
     7a4:	08 95       	ret

000007a6 <_ZN14SoftwareSerial5setRXEh>:
  _transmitBitMask = digitalPinToBitMask(tx);
  uint8_t port = digitalPinToPort(tx);
  _transmitPortRegister = portOutputRegister(port);
}

void SoftwareSerial::setRX(uint8_t rx)
     7a6:	1f 93       	push	r17
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	ec 01       	movw	r28, r24
     7ae:	16 2f       	mov	r17, r22
{
  pinMode(rx, INPUT);
     7b0:	86 2f       	mov	r24, r22
     7b2:	60 e0       	ldi	r22, 0x00	; 0
     7b4:	0e 94 42 08 	call	0x1084	; 0x1084 <pinMode>
  if (!_inverse_logic)
     7b8:	8b 8d       	ldd	r24, Y+27	; 0x1b
     7ba:	81 fd       	sbrc	r24, 1
     7bc:	04 c0       	rjmp	.+8      	; 0x7c6 <_ZN14SoftwareSerial5setRXEh+0x20>
    digitalWrite(rx, HIGH);  // pullup for normal logic!
     7be:	81 2f       	mov	r24, r17
     7c0:	61 e0       	ldi	r22, 0x01	; 1
     7c2:	0e 94 81 08 	call	0x1102	; 0x1102 <digitalWrite>
  _receivePin = rx;
     7c6:	1c 87       	std	Y+12, r17	; 0x0c
  _receiveBitMask = digitalPinToBitMask(rx);
     7c8:	21 2f       	mov	r18, r17
     7ca:	30 e0       	ldi	r19, 0x00	; 0
     7cc:	c9 01       	movw	r24, r18
     7ce:	86 5d       	subi	r24, 0xD6	; 214
     7d0:	9e 4f       	sbci	r25, 0xFE	; 254
     7d2:	fc 01       	movw	r30, r24
     7d4:	84 91       	lpm	r24, Z+
     7d6:	8d 87       	std	Y+13, r24	; 0x0d
  uint8_t port = digitalPinToPort(rx);
     7d8:	2a 5e       	subi	r18, 0xEA	; 234
     7da:	3e 4f       	sbci	r19, 0xFE	; 254
     7dc:	f9 01       	movw	r30, r18
     7de:	64 91       	lpm	r22, Z+
  _receivePortRegister = portInputRegister(port);
     7e0:	e6 2f       	mov	r30, r22
     7e2:	f0 e0       	ldi	r31, 0x00	; 0
     7e4:	ee 0f       	add	r30, r30
     7e6:	ff 1f       	adc	r31, r31
     7e8:	e4 5f       	subi	r30, 0xF4	; 244
     7ea:	fe 4f       	sbci	r31, 0xFE	; 254
     7ec:	85 91       	lpm	r24, Z+
     7ee:	94 91       	lpm	r25, Z+
     7f0:	9f 87       	std	Y+15, r25	; 0x0f
     7f2:	8e 87       	std	Y+14, r24	; 0x0e
}
     7f4:	df 91       	pop	r29
     7f6:	cf 91       	pop	r28
     7f8:	1f 91       	pop	r17
     7fa:	08 95       	ret

000007fc <_ZN14SoftwareSerial5setTXEh>:
SoftwareSerial::~SoftwareSerial()
{
  end();
}

void SoftwareSerial::setTX(uint8_t tx)
     7fc:	ff 92       	push	r15
     7fe:	0f 93       	push	r16
     800:	1f 93       	push	r17
     802:	8c 01       	movw	r16, r24
     804:	f6 2e       	mov	r15, r22
{
  pinMode(tx, OUTPUT);
     806:	86 2f       	mov	r24, r22
     808:	61 e0       	ldi	r22, 0x01	; 1
     80a:	0e 94 42 08 	call	0x1084	; 0x1084 <pinMode>
  digitalWrite(tx, HIGH);
     80e:	8f 2d       	mov	r24, r15
     810:	61 e0       	ldi	r22, 0x01	; 1
     812:	0e 94 81 08 	call	0x1102	; 0x1102 <digitalWrite>
  _transmitBitMask = digitalPinToBitMask(tx);
     816:	8f 2d       	mov	r24, r15
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	fc 01       	movw	r30, r24
     81c:	e6 5d       	subi	r30, 0xD6	; 214
     81e:	fe 4f       	sbci	r31, 0xFE	; 254
     820:	e4 91       	lpm	r30, Z+
     822:	d8 01       	movw	r26, r16
     824:	50 96       	adiw	r26, 0x10	; 16
     826:	ec 93       	st	X, r30
     828:	50 97       	sbiw	r26, 0x10	; 16
  uint8_t port = digitalPinToPort(tx);
     82a:	8a 5e       	subi	r24, 0xEA	; 234
     82c:	9e 4f       	sbci	r25, 0xFE	; 254
     82e:	fc 01       	movw	r30, r24
     830:	64 91       	lpm	r22, Z+
  _transmitPortRegister = portOutputRegister(port);
     832:	e6 2f       	mov	r30, r22
     834:	f0 e0       	ldi	r31, 0x00	; 0
     836:	ee 0f       	add	r30, r30
     838:	ff 1f       	adc	r31, r31
     83a:	ee 5f       	subi	r30, 0xFE	; 254
     83c:	fe 4f       	sbci	r31, 0xFE	; 254
     83e:	85 91       	lpm	r24, Z+
     840:	94 91       	lpm	r25, Z+
     842:	52 96       	adiw	r26, 0x12	; 18
     844:	9c 93       	st	X, r25
     846:	8e 93       	st	-X, r24
     848:	51 97       	sbiw	r26, 0x11	; 17
}
     84a:	1f 91       	pop	r17
     84c:	0f 91       	pop	r16
     84e:	ff 90       	pop	r15
     850:	08 95       	ret

00000852 <_ZN14SoftwareSerialC1Ehhb>:
#endif

//
// Constructor
//
SoftwareSerial::SoftwareSerial(uint8_t receivePin, uint8_t transmitPin, bool inverse_logic /* = false */) : 
     852:	ff 92       	push	r15
     854:	0f 93       	push	r16
     856:	1f 93       	push	r17
     858:	8c 01       	movw	r16, r24
     85a:	f6 2e       	mov	r15, r22
  public:
    Print() : write_error(0) {}
     85c:	fc 01       	movw	r30, r24
     85e:	13 82       	std	Z+3, r1	; 0x03
     860:	12 82       	std	Z+2, r1	; 0x02
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
     862:	88 ee       	ldi	r24, 0xE8	; 232
     864:	93 e0       	ldi	r25, 0x03	; 3
     866:	a0 e0       	ldi	r26, 0x00	; 0
     868:	b0 e0       	ldi	r27, 0x00	; 0
     86a:	84 83       	std	Z+4, r24	; 0x04
     86c:	95 83       	std	Z+5, r25	; 0x05
     86e:	a6 83       	std	Z+6, r26	; 0x06
     870:	b7 83       	std	Z+7, r27	; 0x07
  _rx_delay_centering(0),
  _rx_delay_intrabit(0),
  _rx_delay_stopbit(0),
  _tx_delay(0),
  _buffer_overflow(false),
  _inverse_logic(inverse_logic)
     872:	8e e1       	ldi	r24, 0x1E	; 30
     874:	91 e0       	ldi	r25, 0x01	; 1
     876:	91 83       	std	Z+1, r25	; 0x01
     878:	80 83       	st	Z, r24
     87a:	14 8a       	std	Z+20, r1	; 0x14
     87c:	13 8a       	std	Z+19, r1	; 0x13
     87e:	16 8a       	std	Z+22, r1	; 0x16
     880:	15 8a       	std	Z+21, r1	; 0x15
     882:	10 8e       	std	Z+24, r1	; 0x18
     884:	17 8a       	std	Z+23, r1	; 0x17
     886:	12 8e       	std	Z+26, r1	; 0x1a
     888:	11 8e       	std	Z+25, r1	; 0x19
     88a:	83 8d       	ldd	r24, Z+27	; 0x1b
     88c:	21 70       	andi	r18, 0x01	; 1
     88e:	22 0f       	add	r18, r18
     890:	8c 7f       	andi	r24, 0xFC	; 252
     892:	82 2b       	or	r24, r18
     894:	83 8f       	std	Z+27, r24	; 0x1b
{
  setTX(transmitPin);
     896:	c8 01       	movw	r24, r16
     898:	64 2f       	mov	r22, r20
     89a:	0e 94 fe 03 	call	0x7fc	; 0x7fc <_ZN14SoftwareSerial5setTXEh>
  setRX(receivePin);
     89e:	c8 01       	movw	r24, r16
     8a0:	6f 2d       	mov	r22, r15
     8a2:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_ZN14SoftwareSerial5setRXEh>
}
     8a6:	1f 91       	pop	r17
     8a8:	0f 91       	pop	r16
     8aa:	ff 90       	pop	r15
     8ac:	08 95       	ret

000008ae <_Z41__static_initialization_and_destruction_0ii>:
		wut = Serial.read();
//		String starter = "To BT: ";
//		Serial.println(starter + wut);
		blueToothSerial.write(wut);
	}
}
     8ae:	81 30       	cpi	r24, 0x01	; 1
     8b0:	91 05       	cpc	r25, r1
     8b2:	59 f4       	brne	.+22     	; 0x8ca <_Z41__static_initialization_and_destruction_0ii+0x1c>
     8b4:	6f 5f       	subi	r22, 0xFF	; 255
     8b6:	7f 4f       	sbci	r23, 0xFF	; 255
     8b8:	89 f4       	brne	.+34     	; 0x8dc <_Z41__static_initialization_and_destruction_0ii+0x2e>
 Uses softserial on D9 (RxD),D10 (TxD) to talk to bluetooth modem
 */

#define RxD 6
#define TxD 7
SoftwareSerial blueToothSerial(RxD, TxD);
     8ba:	8e e7       	ldi	r24, 0x7E	; 126
     8bc:	91 e0       	ldi	r25, 0x01	; 1
     8be:	66 e0       	ldi	r22, 0x06	; 6
     8c0:	47 e0       	ldi	r20, 0x07	; 7
     8c2:	20 e0       	ldi	r18, 0x00	; 0
     8c4:	0e 94 29 04 	call	0x852	; 0x852 <_ZN14SoftwareSerialC1Ehhb>
     8c8:	08 95       	ret
     8ca:	89 2b       	or	r24, r25
     8cc:	39 f4       	brne	.+14     	; 0x8dc <_Z41__static_initialization_and_destruction_0ii+0x2e>
     8ce:	6f 5f       	subi	r22, 0xFF	; 255
     8d0:	7f 4f       	sbci	r23, 0xFF	; 255
     8d2:	21 f4       	brne	.+8      	; 0x8dc <_Z41__static_initialization_and_destruction_0ii+0x2e>
     8d4:	8e e7       	ldi	r24, 0x7E	; 126
     8d6:	91 e0       	ldi	r25, 0x01	; 1
     8d8:	0e 94 b0 02 	call	0x560	; 0x560 <_ZN14SoftwareSerialD1Ev>
     8dc:	08 95       	ret

000008de <_GLOBAL__D_blueToothSerial>:
		wut = Serial.read();
//		String starter = "To BT: ";
//		Serial.println(starter + wut);
		blueToothSerial.write(wut);
	}
}
     8de:	80 e0       	ldi	r24, 0x00	; 0
     8e0:	90 e0       	ldi	r25, 0x00	; 0
     8e2:	6f ef       	ldi	r22, 0xFF	; 255
     8e4:	7f ef       	ldi	r23, 0xFF	; 255
     8e6:	0e 94 57 04 	call	0x8ae	; 0x8ae <_Z41__static_initialization_and_destruction_0ii>
     8ea:	08 95       	ret

000008ec <_GLOBAL__I_blueToothSerial>:
     8ec:	81 e0       	ldi	r24, 0x01	; 1
     8ee:	90 e0       	ldi	r25, 0x00	; 0
     8f0:	6f ef       	ldi	r22, 0xFF	; 255
     8f2:	7f ef       	ldi	r23, 0xFF	; 255
     8f4:	0e 94 57 04 	call	0x8ae	; 0x8ae <_Z41__static_initialization_and_destruction_0ii>
     8f8:	08 95       	ret

000008fa <loop>:
	blueToothSerial.begin(115200); //Set BluetoothV3 baud rate to 38400
	delay(1000);
}

void loop() {
	if (displayed != 1) {
     8fa:	80 91 9a 01 	lds	r24, 0x019A
     8fe:	90 91 9b 01 	lds	r25, 0x019B
     902:	01 97       	sbiw	r24, 0x01	; 1
     904:	61 f0       	breq	.+24     	; 0x91e <__stack+0x1f>
		Serial.println("Keep it coming...");
     906:	84 e2       	ldi	r24, 0x24	; 36
     908:	92 e0       	ldi	r25, 0x02	; 2
     90a:	60 e0       	ldi	r22, 0x00	; 0
     90c:	71 e0       	ldi	r23, 0x01	; 1
     90e:	0e 94 44 07 	call	0xe88	; 0xe88 <_ZN5Print7printlnEPKc>
		displayed = 1;
     912:	81 e0       	ldi	r24, 0x01	; 1
     914:	90 e0       	ldi	r25, 0x00	; 0
     916:	90 93 9b 01 	sts	0x019B, r25
     91a:	80 93 9a 01 	sts	0x019A, r24
	}
	int wut;
	if (blueToothSerial.available()) {
     91e:	8e e7       	ldi	r24, 0x7E	; 126
     920:	91 e0       	ldi	r25, 0x01	; 1
     922:	0e 94 da 02 	call	0x5b4	; 0x5b4 <_ZN14SoftwareSerial9availableEv>
     926:	89 2b       	or	r24, r25
     928:	69 f0       	breq	.+26     	; 0x944 <__stack+0x45>
		wut = Serial.read();
     92a:	84 e2       	ldi	r24, 0x24	; 36
     92c:	92 e0       	ldi	r25, 0x02	; 2
     92e:	0e 94 22 06 	call	0xc44	; 0xc44 <_ZN14HardwareSerial4readEv>
//		String starter = "To Serial: ";
//		Serial.println(starter + wut);
		Serial.write(blueToothSerial.read());
     932:	8e e7       	ldi	r24, 0x7E	; 126
     934:	91 e0       	ldi	r25, 0x01	; 1
     936:	0e 94 b9 02 	call	0x572	; 0x572 <_ZN14SoftwareSerial4readEv>
     93a:	68 2f       	mov	r22, r24
     93c:	84 e2       	ldi	r24, 0x24	; 36
     93e:	92 e0       	ldi	r25, 0x02	; 2
     940:	0e 94 5d 06 	call	0xcba	; 0xcba <_ZN14HardwareSerial5writeEh>
	}
	if (Serial.available()) {
     944:	84 e2       	ldi	r24, 0x24	; 36
     946:	92 e0       	ldi	r25, 0x02	; 2
     948:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <_ZN14HardwareSerial9availableEv>
     94c:	89 2b       	or	r24, r25
     94e:	49 f0       	breq	.+18     	; 0x962 <__stack+0x63>
		wut = Serial.read();
     950:	84 e2       	ldi	r24, 0x24	; 36
     952:	92 e0       	ldi	r25, 0x02	; 2
     954:	0e 94 22 06 	call	0xc44	; 0xc44 <_ZN14HardwareSerial4readEv>
     958:	68 2f       	mov	r22, r24
//		String starter = "To BT: ";
//		Serial.println(starter + wut);
		blueToothSerial.write(wut);
     95a:	8e e7       	ldi	r24, 0x7E	; 126
     95c:	91 e0       	ldi	r25, 0x01	; 1
     95e:	0e 94 f4 02 	call	0x5e8	; 0x5e8 <_ZN14SoftwareSerial5writeEh>
     962:	08 95       	ret

00000964 <_Z24setupBlueToothConnectionv>:
	Serial.println("Started");
	displayed = 0;
}

void setupBlueToothConnection() {
	blueToothSerial.begin(115200); //Set BluetoothV3 baud rate to 38400
     964:	8e e7       	ldi	r24, 0x7E	; 126
     966:	91 e0       	ldi	r25, 0x01	; 1
     968:	40 e0       	ldi	r20, 0x00	; 0
     96a:	52 ec       	ldi	r21, 0xC2	; 194
     96c:	61 e0       	ldi	r22, 0x01	; 1
     96e:	70 e0       	ldi	r23, 0x00	; 0
     970:	0e 94 be 01 	call	0x37c	; 0x37c <_ZN14SoftwareSerial5beginEl>
	delay(1000);
     974:	68 ee       	ldi	r22, 0xE8	; 232
     976:	73 e0       	ldi	r23, 0x03	; 3
     978:	80 e0       	ldi	r24, 0x00	; 0
     97a:	90 e0       	ldi	r25, 0x00	; 0
     97c:	0e 94 ae 07 	call	0xf5c	; 0xf5c <delay>
}
     980:	08 95       	ret

00000982 <setup>:
#define RxD 6
#define TxD 7
SoftwareSerial blueToothSerial(RxD, TxD);
char incoming;
int displayed;
void setup() {
     982:	0f 93       	push	r16
     984:	1f 93       	push	r17
	Serial.begin(9600);
     986:	04 e2       	ldi	r16, 0x24	; 36
     988:	12 e0       	ldi	r17, 0x02	; 2
     98a:	c8 01       	movw	r24, r16
     98c:	40 e8       	ldi	r20, 0x80	; 128
     98e:	55 e2       	ldi	r21, 0x25	; 37
     990:	60 e0       	ldi	r22, 0x00	; 0
     992:	70 e0       	ldi	r23, 0x00	; 0
     994:	0e 94 6b 05 	call	0xad6	; 0xad6 <_ZN14HardwareSerial5beginEm>
	delay(1000);
     998:	68 ee       	ldi	r22, 0xE8	; 232
     99a:	73 e0       	ldi	r23, 0x03	; 3
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	90 e0       	ldi	r25, 0x00	; 0
     9a0:	0e 94 ae 07 	call	0xf5c	; 0xf5c <delay>
	pinMode(RxD, INPUT);
     9a4:	86 e0       	ldi	r24, 0x06	; 6
     9a6:	60 e0       	ldi	r22, 0x00	; 0
     9a8:	0e 94 42 08 	call	0x1084	; 0x1084 <pinMode>
	pinMode(TxD, OUTPUT);
     9ac:	87 e0       	ldi	r24, 0x07	; 7
     9ae:	61 e0       	ldi	r22, 0x01	; 1
     9b0:	0e 94 42 08 	call	0x1084	; 0x1084 <pinMode>
	setupBlueToothConnection();
     9b4:	0e 94 b2 04 	call	0x964	; 0x964 <_Z24setupBlueToothConnectionv>
	Serial.println("Started");
     9b8:	c8 01       	movw	r24, r16
     9ba:	62 e1       	ldi	r22, 0x12	; 18
     9bc:	71 e0       	ldi	r23, 0x01	; 1
     9be:	0e 94 44 07 	call	0xe88	; 0xe88 <_ZN5Print7printlnEPKc>
	displayed = 0;
     9c2:	10 92 9b 01 	sts	0x019B, r1
     9c6:	10 92 9a 01 	sts	0x019A, r1
}
     9ca:	1f 91       	pop	r17
     9cc:	0f 91       	pop	r16
     9ce:	08 95       	ret

000009d0 <_Z11serialEventv>:
    !defined(SIG_UART0_RECV) && !defined(USART0_RX_vect) && \
	!defined(SIG_UART_RECV)
  #error "Don't know what the Data Received vector is called for the first UART"
#else
  void serialEvent() __attribute__((weak));
  void serialEvent() {}
     9d0:	08 95       	ret

000009d2 <__vector_18>:
  #define serialEvent_implemented
#if defined(USART_RX_vect)
  SIGNAL(USART_RX_vect)
     9d2:	1f 92       	push	r1
     9d4:	0f 92       	push	r0
     9d6:	0f b6       	in	r0, 0x3f	; 63
     9d8:	0f 92       	push	r0
     9da:	11 24       	eor	r1, r1
     9dc:	2f 93       	push	r18
     9de:	3f 93       	push	r19
     9e0:	4f 93       	push	r20
     9e2:	8f 93       	push	r24
     9e4:	9f 93       	push	r25
     9e6:	ef 93       	push	r30
     9e8:	ff 93       	push	r31
#elif defined(SIG_UART_RECV)
  SIGNAL(SIG_UART_RECV)
#endif
  {
  #if defined(UDR0)
    unsigned char c  =  UDR0;
     9ea:	40 91 c6 00 	lds	r20, 0x00C6
  ring_buffer tx_buffer3  =  { { 0 }, 0, 0 };
#endif

inline void store_char(unsigned char c, ring_buffer *buffer)
{
  int i = (unsigned int)(buffer->head + 1) % SERIAL_BUFFER_SIZE;
     9ee:	20 91 dc 01 	lds	r18, 0x01DC
     9f2:	30 91 dd 01 	lds	r19, 0x01DD

  // if we should be storing the received character into the location
  // just before the tail (meaning that the head would advance to the
  // current location of the tail), we're about to overflow the buffer
  // and so we don't write the character or advance the head.
  if (i != buffer->tail) {
     9f6:	2f 5f       	subi	r18, 0xFF	; 255
     9f8:	3f 4f       	sbci	r19, 0xFF	; 255
     9fa:	2f 73       	andi	r18, 0x3F	; 63
     9fc:	30 70       	andi	r19, 0x00	; 0
     9fe:	80 91 de 01 	lds	r24, 0x01DE
     a02:	90 91 df 01 	lds	r25, 0x01DF
     a06:	28 17       	cp	r18, r24
     a08:	39 07       	cpc	r19, r25
     a0a:	59 f0       	breq	.+22     	; 0xa22 <__vector_18+0x50>
    buffer->buffer[buffer->head] = c;
     a0c:	e0 91 dc 01 	lds	r30, 0x01DC
     a10:	f0 91 dd 01 	lds	r31, 0x01DD
     a14:	e4 56       	subi	r30, 0x64	; 100
     a16:	fe 4f       	sbci	r31, 0xFE	; 254
     a18:	40 83       	st	Z, r20
    buffer->head = i;
     a1a:	30 93 dd 01 	sts	0x01DD, r19
     a1e:	20 93 dc 01 	sts	0x01DC, r18
    unsigned char c  =  UDR;
  #else
    #error UDR not defined
  #endif
    store_char(c, &rx_buffer);
  }
     a22:	ff 91       	pop	r31
     a24:	ef 91       	pop	r30
     a26:	9f 91       	pop	r25
     a28:	8f 91       	pop	r24
     a2a:	4f 91       	pop	r20
     a2c:	3f 91       	pop	r19
     a2e:	2f 91       	pop	r18
     a30:	0f 90       	pop	r0
     a32:	0f be       	out	0x3f, r0	; 63
     a34:	0f 90       	pop	r0
     a36:	1f 90       	pop	r1
     a38:	18 95       	reti

00000a3a <_Z14serialEventRunv>:
  _rx_buffer->head = _rx_buffer->tail;
}

int HardwareSerial::available(void)
{
  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
     a3a:	e0 91 30 02 	lds	r30, 0x0230
     a3e:	f0 91 31 02 	lds	r31, 0x0231
     a42:	e0 5c       	subi	r30, 0xC0	; 192
     a44:	ff 4f       	sbci	r31, 0xFF	; 255
     a46:	81 91       	ld	r24, Z+
     a48:	91 91       	ld	r25, Z+
     a4a:	20 81       	ld	r18, Z
     a4c:	31 81       	ldd	r19, Z+1	; 0x01
#endif

void serialEventRun(void)
{
#ifdef serialEvent_implemented
  if (Serial.available()) serialEvent();
     a4e:	82 1b       	sub	r24, r18
     a50:	93 0b       	sbc	r25, r19
     a52:	8f 73       	andi	r24, 0x3F	; 63
     a54:	90 70       	andi	r25, 0x00	; 0
     a56:	89 2b       	or	r24, r25
     a58:	11 f0       	breq	.+4      	; 0xa5e <_Z14serialEventRunv+0x24>
     a5a:	0e 94 e8 04 	call	0x9d0	; 0x9d0 <_Z11serialEventv>
     a5e:	08 95       	ret

00000a60 <__vector_19>:
#elif defined(UART_UDRE_vect)
ISR(UART_UDRE_vect)
#elif defined(USART0_UDRE_vect)
ISR(USART0_UDRE_vect)
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
     a60:	1f 92       	push	r1
     a62:	0f 92       	push	r0
     a64:	0f b6       	in	r0, 0x3f	; 63
     a66:	0f 92       	push	r0
     a68:	11 24       	eor	r1, r1
     a6a:	2f 93       	push	r18
     a6c:	3f 93       	push	r19
     a6e:	8f 93       	push	r24
     a70:	9f 93       	push	r25
     a72:	ef 93       	push	r30
     a74:	ff 93       	push	r31
#endif
{
  if (tx_buffer.head == tx_buffer.tail) {
     a76:	20 91 20 02 	lds	r18, 0x0220
     a7a:	30 91 21 02 	lds	r19, 0x0221
     a7e:	80 91 22 02 	lds	r24, 0x0222
     a82:	90 91 23 02 	lds	r25, 0x0223
     a86:	28 17       	cp	r18, r24
     a88:	39 07       	cpc	r19, r25
     a8a:	31 f4       	brne	.+12     	; 0xa98 <__vector_19+0x38>
	// Buffer empty, so disable interrupts
#if defined(UCSR0B)
    cbi(UCSR0B, UDRIE0);
     a8c:	80 91 c1 00 	lds	r24, 0x00C1
     a90:	8f 7d       	andi	r24, 0xDF	; 223
     a92:	80 93 c1 00 	sts	0x00C1, r24
     a96:	14 c0       	rjmp	.+40     	; 0xac0 <__vector_19+0x60>
    cbi(UCSRB, UDRIE);
#endif
  }
  else {
    // There is more data in the output buffer. Send the next byte
    unsigned char c = tx_buffer.buffer[tx_buffer.tail];
     a98:	e0 91 22 02 	lds	r30, 0x0222
     a9c:	f0 91 23 02 	lds	r31, 0x0223
     aa0:	e0 52       	subi	r30, 0x20	; 32
     aa2:	fe 4f       	sbci	r31, 0xFE	; 254
     aa4:	20 81       	ld	r18, Z
    tx_buffer.tail = (tx_buffer.tail + 1) % SERIAL_BUFFER_SIZE;
     aa6:	80 91 22 02 	lds	r24, 0x0222
     aaa:	90 91 23 02 	lds	r25, 0x0223
     aae:	01 96       	adiw	r24, 0x01	; 1
     ab0:	8f 73       	andi	r24, 0x3F	; 63
     ab2:	90 70       	andi	r25, 0x00	; 0
     ab4:	90 93 23 02 	sts	0x0223, r25
     ab8:	80 93 22 02 	sts	0x0222, r24
	
  #if defined(UDR0)
    UDR0 = c;
     abc:	20 93 c6 00 	sts	0x00C6, r18
    UDR = c;
  #else
    #error UDR not defined
  #endif
  }
}
     ac0:	ff 91       	pop	r31
     ac2:	ef 91       	pop	r30
     ac4:	9f 91       	pop	r25
     ac6:	8f 91       	pop	r24
     ac8:	3f 91       	pop	r19
     aca:	2f 91       	pop	r18
     acc:	0f 90       	pop	r0
     ace:	0f be       	out	0x3f, r0	; 63
     ad0:	0f 90       	pop	r0
     ad2:	1f 90       	pop	r1
     ad4:	18 95       	reti

00000ad6 <_ZN14HardwareSerial5beginEm>:
  _u2x = u2x;
}

// Public Methods //////////////////////////////////////////////////////////////

void HardwareSerial::begin(unsigned long baud)
     ad6:	af 92       	push	r10
     ad8:	bf 92       	push	r11
     ada:	df 92       	push	r13
     adc:	ef 92       	push	r14
     ade:	ff 92       	push	r15
     ae0:	0f 93       	push	r16
     ae2:	1f 93       	push	r17
     ae4:	cf 93       	push	r28
     ae6:	df 93       	push	r29
     ae8:	ec 01       	movw	r28, r24
     aea:	7a 01       	movw	r14, r20
     aec:	8b 01       	movw	r16, r22
     aee:	dd 24       	eor	r13, r13
     af0:	40 30       	cpi	r20, 0x00	; 0
     af2:	81 ee       	ldi	r24, 0xE1	; 225
     af4:	58 07       	cpc	r21, r24
     af6:	80 e0       	ldi	r24, 0x00	; 0
     af8:	68 07       	cpc	r22, r24
     afa:	80 e0       	ldi	r24, 0x00	; 0
     afc:	78 07       	cpc	r23, r24
     afe:	11 f0       	breq	.+4      	; 0xb04 <_ZN14HardwareSerial5beginEm+0x2e>
     b00:	dd 24       	eor	r13, r13
     b02:	d3 94       	inc	r13
#endif

try_again:
  
  if (use_u2x) {
    *_ucsra = 1 << _u2x;
     b04:	91 e0       	ldi	r25, 0x01	; 1
     b06:	a9 2e       	mov	r10, r25
     b08:	b1 2c       	mov	r11, r1
     b0a:	ec 89       	ldd	r30, Y+20	; 0x14
     b0c:	fd 89       	ldd	r31, Y+21	; 0x15
  }
#endif

try_again:
  
  if (use_u2x) {
     b0e:	dd 20       	and	r13, r13
     b10:	69 f0       	breq	.+26     	; 0xb2c <_ZN14HardwareSerial5beginEm+0x56>
    *_ucsra = 1 << _u2x;
     b12:	c5 01       	movw	r24, r10
     b14:	0e 8c       	ldd	r0, Y+30	; 0x1e
     b16:	02 c0       	rjmp	.+4      	; 0xb1c <_ZN14HardwareSerial5beginEm+0x46>
     b18:	88 0f       	add	r24, r24
     b1a:	99 1f       	adc	r25, r25
     b1c:	0a 94       	dec	r0
     b1e:	e2 f7       	brpl	.-8      	; 0xb18 <_ZN14HardwareSerial5beginEm+0x42>
     b20:	80 83       	st	Z, r24
    baud_setting = (F_CPU / 4 / baud - 1) / 2;
     b22:	60 e0       	ldi	r22, 0x00	; 0
     b24:	79 e0       	ldi	r23, 0x09	; 9
     b26:	8d e3       	ldi	r24, 0x3D	; 61
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	05 c0       	rjmp	.+10     	; 0xb36 <_ZN14HardwareSerial5beginEm+0x60>
  } else {
    *_ucsra = 0;
     b2c:	10 82       	st	Z, r1
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
     b2e:	60 e8       	ldi	r22, 0x80	; 128
     b30:	74 e8       	ldi	r23, 0x84	; 132
     b32:	8e e1       	ldi	r24, 0x1E	; 30
     b34:	90 e0       	ldi	r25, 0x00	; 0
     b36:	a8 01       	movw	r20, r16
     b38:	97 01       	movw	r18, r14
     b3a:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <__udivmodsi4>
     b3e:	21 50       	subi	r18, 0x01	; 1
     b40:	30 40       	sbci	r19, 0x00	; 0
     b42:	40 40       	sbci	r20, 0x00	; 0
     b44:	50 40       	sbci	r21, 0x00	; 0
     b46:	56 95       	lsr	r21
     b48:	47 95       	ror	r20
     b4a:	37 95       	ror	r19
     b4c:	27 95       	ror	r18
  }
  
  if ((baud_setting > 4095) && use_u2x)
     b4e:	80 e1       	ldi	r24, 0x10	; 16
     b50:	20 30       	cpi	r18, 0x00	; 0
     b52:	38 07       	cpc	r19, r24
     b54:	20 f0       	brcs	.+8      	; 0xb5e <_ZN14HardwareSerial5beginEm+0x88>
     b56:	dd 20       	and	r13, r13
     b58:	11 f0       	breq	.+4      	; 0xb5e <_ZN14HardwareSerial5beginEm+0x88>
     b5a:	dd 24       	eor	r13, r13
     b5c:	d6 cf       	rjmp	.-84     	; 0xb0a <_ZN14HardwareSerial5beginEm+0x34>
    use_u2x = false;
    goto try_again;
  }

  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
     b5e:	e8 89       	ldd	r30, Y+16	; 0x10
     b60:	f9 89       	ldd	r31, Y+17	; 0x11
     b62:	30 83       	st	Z, r19
  *_ubrrl = baud_setting;
     b64:	ea 89       	ldd	r30, Y+18	; 0x12
     b66:	fb 89       	ldd	r31, Y+19	; 0x13
     b68:	20 83       	st	Z, r18

  sbi(*_ucsrb, _rxen);
     b6a:	ee 89       	ldd	r30, Y+22	; 0x16
     b6c:	ff 89       	ldd	r31, Y+23	; 0x17
     b6e:	40 81       	ld	r20, Z
     b70:	21 e0       	ldi	r18, 0x01	; 1
     b72:	30 e0       	ldi	r19, 0x00	; 0
     b74:	c9 01       	movw	r24, r18
     b76:	0a 8c       	ldd	r0, Y+26	; 0x1a
     b78:	02 c0       	rjmp	.+4      	; 0xb7e <_ZN14HardwareSerial5beginEm+0xa8>
     b7a:	88 0f       	add	r24, r24
     b7c:	99 1f       	adc	r25, r25
     b7e:	0a 94       	dec	r0
     b80:	e2 f7       	brpl	.-8      	; 0xb7a <_ZN14HardwareSerial5beginEm+0xa4>
     b82:	48 2b       	or	r20, r24
     b84:	40 83       	st	Z, r20
  sbi(*_ucsrb, _txen);
     b86:	ee 89       	ldd	r30, Y+22	; 0x16
     b88:	ff 89       	ldd	r31, Y+23	; 0x17
     b8a:	40 81       	ld	r20, Z
     b8c:	c9 01       	movw	r24, r18
     b8e:	0b 8c       	ldd	r0, Y+27	; 0x1b
     b90:	02 c0       	rjmp	.+4      	; 0xb96 <_ZN14HardwareSerial5beginEm+0xc0>
     b92:	88 0f       	add	r24, r24
     b94:	99 1f       	adc	r25, r25
     b96:	0a 94       	dec	r0
     b98:	e2 f7       	brpl	.-8      	; 0xb92 <_ZN14HardwareSerial5beginEm+0xbc>
     b9a:	48 2b       	or	r20, r24
     b9c:	40 83       	st	Z, r20
  sbi(*_ucsrb, _rxcie);
     b9e:	ee 89       	ldd	r30, Y+22	; 0x16
     ba0:	ff 89       	ldd	r31, Y+23	; 0x17
     ba2:	40 81       	ld	r20, Z
     ba4:	c9 01       	movw	r24, r18
     ba6:	0c 8c       	ldd	r0, Y+28	; 0x1c
     ba8:	02 c0       	rjmp	.+4      	; 0xbae <_ZN14HardwareSerial5beginEm+0xd8>
     baa:	88 0f       	add	r24, r24
     bac:	99 1f       	adc	r25, r25
     bae:	0a 94       	dec	r0
     bb0:	e2 f7       	brpl	.-8      	; 0xbaa <_ZN14HardwareSerial5beginEm+0xd4>
     bb2:	48 2b       	or	r20, r24
     bb4:	40 83       	st	Z, r20
  cbi(*_ucsrb, _udrie);
     bb6:	ee 89       	ldd	r30, Y+22	; 0x16
     bb8:	ff 89       	ldd	r31, Y+23	; 0x17
     bba:	80 81       	ld	r24, Z
     bbc:	0d 8c       	ldd	r0, Y+29	; 0x1d
     bbe:	02 c0       	rjmp	.+4      	; 0xbc4 <_ZN14HardwareSerial5beginEm+0xee>
     bc0:	22 0f       	add	r18, r18
     bc2:	33 1f       	adc	r19, r19
     bc4:	0a 94       	dec	r0
     bc6:	e2 f7       	brpl	.-8      	; 0xbc0 <_ZN14HardwareSerial5beginEm+0xea>
     bc8:	20 95       	com	r18
     bca:	28 23       	and	r18, r24
     bcc:	20 83       	st	Z, r18
}
     bce:	df 91       	pop	r29
     bd0:	cf 91       	pop	r28
     bd2:	1f 91       	pop	r17
     bd4:	0f 91       	pop	r16
     bd6:	ff 90       	pop	r15
     bd8:	ef 90       	pop	r14
     bda:	df 90       	pop	r13
     bdc:	bf 90       	pop	r11
     bde:	af 90       	pop	r10
     be0:	08 95       	ret

00000be2 <_ZN14HardwareSerial9availableEv>:
  _rx_buffer->head = _rx_buffer->tail;
}

int HardwareSerial::available(void)
{
  return (unsigned int)(SERIAL_BUFFER_SIZE + _rx_buffer->head - _rx_buffer->tail) % SERIAL_BUFFER_SIZE;
     be2:	dc 01       	movw	r26, r24
     be4:	1c 96       	adiw	r26, 0x0c	; 12
     be6:	ed 91       	ld	r30, X+
     be8:	fc 91       	ld	r31, X
     bea:	1d 97       	sbiw	r26, 0x0d	; 13
     bec:	e0 5c       	subi	r30, 0xC0	; 192
     bee:	ff 4f       	sbci	r31, 0xFF	; 255
     bf0:	21 91       	ld	r18, Z+
     bf2:	31 91       	ld	r19, Z+
     bf4:	80 81       	ld	r24, Z
     bf6:	91 81       	ldd	r25, Z+1	; 0x01
     bf8:	28 1b       	sub	r18, r24
     bfa:	39 0b       	sbc	r19, r25
     bfc:	2f 73       	andi	r18, 0x3F	; 63
     bfe:	30 70       	andi	r19, 0x00	; 0
}
     c00:	c9 01       	movw	r24, r18
     c02:	08 95       	ret

00000c04 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
  if (_rx_buffer->head == _rx_buffer->tail) {
     c04:	dc 01       	movw	r26, r24
     c06:	1c 96       	adiw	r26, 0x0c	; 12
     c08:	ed 91       	ld	r30, X+
     c0a:	fc 91       	ld	r31, X
     c0c:	1d 97       	sbiw	r26, 0x0d	; 13
     c0e:	e0 5c       	subi	r30, 0xC0	; 192
     c10:	ff 4f       	sbci	r31, 0xFF	; 255
     c12:	20 81       	ld	r18, Z
     c14:	31 81       	ldd	r19, Z+1	; 0x01
     c16:	e0 54       	subi	r30, 0x40	; 64
     c18:	f0 40       	sbci	r31, 0x00	; 0
     c1a:	df 01       	movw	r26, r30
     c1c:	ae 5b       	subi	r26, 0xBE	; 190
     c1e:	bf 4f       	sbci	r27, 0xFF	; 255
     c20:	8d 91       	ld	r24, X+
     c22:	9c 91       	ld	r25, X
     c24:	11 97       	sbiw	r26, 0x01	; 1
     c26:	28 17       	cp	r18, r24
     c28:	39 07       	cpc	r19, r25
     c2a:	19 f4       	brne	.+6      	; 0xc32 <_ZN14HardwareSerial4peekEv+0x2e>
     c2c:	2f ef       	ldi	r18, 0xFF	; 255
     c2e:	3f ef       	ldi	r19, 0xFF	; 255
     c30:	07 c0       	rjmp	.+14     	; 0xc40 <_ZN14HardwareSerial4peekEv+0x3c>
    return -1;
  } else {
    return _rx_buffer->buffer[_rx_buffer->tail];
     c32:	8d 91       	ld	r24, X+
     c34:	9c 91       	ld	r25, X
     c36:	e8 0f       	add	r30, r24
     c38:	f9 1f       	adc	r31, r25
     c3a:	80 81       	ld	r24, Z
     c3c:	28 2f       	mov	r18, r24
     c3e:	30 e0       	ldi	r19, 0x00	; 0
  }
}
     c40:	c9 01       	movw	r24, r18
     c42:	08 95       	ret

00000c44 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer->head == _rx_buffer->tail) {
     c44:	dc 01       	movw	r26, r24
     c46:	1c 96       	adiw	r26, 0x0c	; 12
     c48:	ed 91       	ld	r30, X+
     c4a:	fc 91       	ld	r31, X
     c4c:	1d 97       	sbiw	r26, 0x0d	; 13
     c4e:	e0 5c       	subi	r30, 0xC0	; 192
     c50:	ff 4f       	sbci	r31, 0xFF	; 255
     c52:	20 81       	ld	r18, Z
     c54:	31 81       	ldd	r19, Z+1	; 0x01
     c56:	e0 54       	subi	r30, 0x40	; 64
     c58:	f0 40       	sbci	r31, 0x00	; 0
     c5a:	df 01       	movw	r26, r30
     c5c:	ae 5b       	subi	r26, 0xBE	; 190
     c5e:	bf 4f       	sbci	r27, 0xFF	; 255
     c60:	8d 91       	ld	r24, X+
     c62:	9c 91       	ld	r25, X
     c64:	11 97       	sbiw	r26, 0x01	; 1
     c66:	28 17       	cp	r18, r24
     c68:	39 07       	cpc	r19, r25
     c6a:	19 f4       	brne	.+6      	; 0xc72 <_ZN14HardwareSerial4readEv+0x2e>
     c6c:	2f ef       	ldi	r18, 0xFF	; 255
     c6e:	3f ef       	ldi	r19, 0xFF	; 255
     c70:	10 c0       	rjmp	.+32     	; 0xc92 <_ZN14HardwareSerial4readEv+0x4e>
    return -1;
  } else {
    unsigned char c = _rx_buffer->buffer[_rx_buffer->tail];
     c72:	8d 91       	ld	r24, X+
     c74:	9c 91       	ld	r25, X
     c76:	11 97       	sbiw	r26, 0x01	; 1
     c78:	e8 0f       	add	r30, r24
     c7a:	f9 1f       	adc	r31, r25
     c7c:	20 81       	ld	r18, Z
    _rx_buffer->tail = (unsigned int)(_rx_buffer->tail + 1) % SERIAL_BUFFER_SIZE;
     c7e:	8d 91       	ld	r24, X+
     c80:	9c 91       	ld	r25, X
     c82:	11 97       	sbiw	r26, 0x01	; 1
     c84:	01 96       	adiw	r24, 0x01	; 1
     c86:	8f 73       	andi	r24, 0x3F	; 63
     c88:	90 70       	andi	r25, 0x00	; 0
     c8a:	11 96       	adiw	r26, 0x01	; 1
     c8c:	9c 93       	st	X, r25
     c8e:	8e 93       	st	-X, r24
    return c;
     c90:	30 e0       	ldi	r19, 0x00	; 0
  }
}
     c92:	c9 01       	movw	r24, r18
     c94:	08 95       	ret

00000c96 <_ZN14HardwareSerial5flushEv>:

void HardwareSerial::flush()
{
  while (_tx_buffer->head != _tx_buffer->tail)
     c96:	fc 01       	movw	r30, r24
     c98:	86 85       	ldd	r24, Z+14	; 0x0e
     c9a:	97 85       	ldd	r25, Z+15	; 0x0f
     c9c:	dc 01       	movw	r26, r24
     c9e:	a0 5c       	subi	r26, 0xC0	; 192
     ca0:	bf 4f       	sbci	r27, 0xFF	; 255
     ca2:	fc 01       	movw	r30, r24
     ca4:	ee 5b       	subi	r30, 0xBE	; 190
     ca6:	ff 4f       	sbci	r31, 0xFF	; 255
     ca8:	2d 91       	ld	r18, X+
     caa:	3c 91       	ld	r19, X
     cac:	11 97       	sbiw	r26, 0x01	; 1
     cae:	80 81       	ld	r24, Z
     cb0:	91 81       	ldd	r25, Z+1	; 0x01
     cb2:	28 17       	cp	r18, r24
     cb4:	39 07       	cpc	r19, r25
     cb6:	c1 f7       	brne	.-16     	; 0xca8 <_ZN14HardwareSerial5flushEv+0x12>
    ;
}
     cb8:	08 95       	ret

00000cba <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	ec 01       	movw	r28, r24
{
  int i = (_tx_buffer->head + 1) % SERIAL_BUFFER_SIZE;
     cc0:	ee 85       	ldd	r30, Y+14	; 0x0e
     cc2:	ff 85       	ldd	r31, Y+15	; 0x0f
     cc4:	e0 5c       	subi	r30, 0xC0	; 192
     cc6:	ff 4f       	sbci	r31, 0xFF	; 255
     cc8:	20 81       	ld	r18, Z
     cca:	31 81       	ldd	r19, Z+1	; 0x01
     ccc:	e0 54       	subi	r30, 0x40	; 64
     cce:	f0 40       	sbci	r31, 0x00	; 0
     cd0:	2f 5f       	subi	r18, 0xFF	; 255
     cd2:	3f 4f       	sbci	r19, 0xFF	; 255
     cd4:	2f 73       	andi	r18, 0x3F	; 63
     cd6:	30 70       	andi	r19, 0x00	; 0
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  // ???: return 0 here instead?
  while (i == _tx_buffer->tail)
     cd8:	df 01       	movw	r26, r30
     cda:	ae 5b       	subi	r26, 0xBE	; 190
     cdc:	bf 4f       	sbci	r27, 0xFF	; 255
     cde:	8d 91       	ld	r24, X+
     ce0:	9c 91       	ld	r25, X
     ce2:	11 97       	sbiw	r26, 0x01	; 1
     ce4:	28 17       	cp	r18, r24
     ce6:	39 07       	cpc	r19, r25
     ce8:	d1 f3       	breq	.-12     	; 0xcde <_ZN14HardwareSerial5writeEh+0x24>
    ;
	
  _tx_buffer->buffer[_tx_buffer->head] = c;
     cea:	e0 5c       	subi	r30, 0xC0	; 192
     cec:	ff 4f       	sbci	r31, 0xFF	; 255
     cee:	80 81       	ld	r24, Z
     cf0:	91 81       	ldd	r25, Z+1	; 0x01
     cf2:	e0 54       	subi	r30, 0x40	; 64
     cf4:	f0 40       	sbci	r31, 0x00	; 0
     cf6:	e8 0f       	add	r30, r24
     cf8:	f9 1f       	adc	r31, r25
     cfa:	60 83       	st	Z, r22
  _tx_buffer->head = i;
     cfc:	ee 85       	ldd	r30, Y+14	; 0x0e
     cfe:	ff 85       	ldd	r31, Y+15	; 0x0f
     d00:	e0 5c       	subi	r30, 0xC0	; 192
     d02:	ff 4f       	sbci	r31, 0xFF	; 255
     d04:	31 83       	std	Z+1, r19	; 0x01
     d06:	20 83       	st	Z, r18
	
  sbi(*_ucsrb, _udrie);
     d08:	ee 89       	ldd	r30, Y+22	; 0x16
     d0a:	ff 89       	ldd	r31, Y+23	; 0x17
     d0c:	20 81       	ld	r18, Z
     d0e:	81 e0       	ldi	r24, 0x01	; 1
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	0d 8c       	ldd	r0, Y+29	; 0x1d
     d14:	02 c0       	rjmp	.+4      	; 0xd1a <_ZN14HardwareSerial5writeEh+0x60>
     d16:	88 0f       	add	r24, r24
     d18:	99 1f       	adc	r25, r25
     d1a:	0a 94       	dec	r0
     d1c:	e2 f7       	brpl	.-8      	; 0xd16 <_ZN14HardwareSerial5writeEh+0x5c>
     d1e:	28 2b       	or	r18, r24
     d20:	20 83       	st	Z, r18
  
  return 1;
}
     d22:	81 e0       	ldi	r24, 0x01	; 1
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	df 91       	pop	r29
     d28:	cf 91       	pop	r28
     d2a:	08 95       	ret

00000d2c <_GLOBAL__I_rx_buffer>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
     d2c:	10 92 27 02 	sts	0x0227, r1
     d30:	10 92 26 02 	sts	0x0226, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
     d34:	88 ee       	ldi	r24, 0xE8	; 232
     d36:	93 e0       	ldi	r25, 0x03	; 3
     d38:	a0 e0       	ldi	r26, 0x00	; 0
     d3a:	b0 e0       	ldi	r27, 0x00	; 0
     d3c:	80 93 28 02 	sts	0x0228, r24
     d40:	90 93 29 02 	sts	0x0229, r25
     d44:	a0 93 2a 02 	sts	0x022A, r26
     d48:	b0 93 2b 02 	sts	0x022B, r27

HardwareSerial::HardwareSerial(ring_buffer *rx_buffer, ring_buffer *tx_buffer,
  volatile uint8_t *ubrrh, volatile uint8_t *ubrrl,
  volatile uint8_t *ucsra, volatile uint8_t *ucsrb,
  volatile uint8_t *udr,
  uint8_t rxen, uint8_t txen, uint8_t rxcie, uint8_t udrie, uint8_t u2x)
     d4c:	8e e2       	ldi	r24, 0x2E	; 46
     d4e:	91 e0       	ldi	r25, 0x01	; 1
     d50:	90 93 25 02 	sts	0x0225, r25
     d54:	80 93 24 02 	sts	0x0224, r24
{
  _rx_buffer = rx_buffer;
     d58:	8c e9       	ldi	r24, 0x9C	; 156
     d5a:	91 e0       	ldi	r25, 0x01	; 1
     d5c:	90 93 31 02 	sts	0x0231, r25
     d60:	80 93 30 02 	sts	0x0230, r24
  _tx_buffer = tx_buffer;
     d64:	80 ee       	ldi	r24, 0xE0	; 224
     d66:	91 e0       	ldi	r25, 0x01	; 1
     d68:	90 93 33 02 	sts	0x0233, r25
     d6c:	80 93 32 02 	sts	0x0232, r24
  _ubrrh = ubrrh;
     d70:	85 ec       	ldi	r24, 0xC5	; 197
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	90 93 35 02 	sts	0x0235, r25
     d78:	80 93 34 02 	sts	0x0234, r24
  _ubrrl = ubrrl;
     d7c:	84 ec       	ldi	r24, 0xC4	; 196
     d7e:	90 e0       	ldi	r25, 0x00	; 0
     d80:	90 93 37 02 	sts	0x0237, r25
     d84:	80 93 36 02 	sts	0x0236, r24
  _ucsra = ucsra;
     d88:	80 ec       	ldi	r24, 0xC0	; 192
     d8a:	90 e0       	ldi	r25, 0x00	; 0
     d8c:	90 93 39 02 	sts	0x0239, r25
     d90:	80 93 38 02 	sts	0x0238, r24
  _ucsrb = ucsrb;
     d94:	81 ec       	ldi	r24, 0xC1	; 193
     d96:	90 e0       	ldi	r25, 0x00	; 0
     d98:	90 93 3b 02 	sts	0x023B, r25
     d9c:	80 93 3a 02 	sts	0x023A, r24
  _udr = udr;
     da0:	86 ec       	ldi	r24, 0xC6	; 198
     da2:	90 e0       	ldi	r25, 0x00	; 0
     da4:	90 93 3d 02 	sts	0x023D, r25
     da8:	80 93 3c 02 	sts	0x023C, r24
  _rxen = rxen;
     dac:	84 e0       	ldi	r24, 0x04	; 4
     dae:	80 93 3e 02 	sts	0x023E, r24
  _txen = txen;
     db2:	83 e0       	ldi	r24, 0x03	; 3
     db4:	80 93 3f 02 	sts	0x023F, r24
  _rxcie = rxcie;
     db8:	87 e0       	ldi	r24, 0x07	; 7
     dba:	80 93 40 02 	sts	0x0240, r24
  _udrie = udrie;
     dbe:	85 e0       	ldi	r24, 0x05	; 5
     dc0:	80 93 41 02 	sts	0x0241, r24
  _u2x = u2x;
     dc4:	81 e0       	ldi	r24, 0x01	; 1
     dc6:	80 93 42 02 	sts	0x0242, r24
// Preinstantiate Objects //////////////////////////////////////////////////////

#if defined(UBRRH) && defined(UBRRL)
  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRRH, &UBRRL, &UCSRA, &UCSRB, &UDR, RXEN, TXEN, RXCIE, UDRIE, U2X);
#elif defined(UBRR0H) && defined(UBRR0L)
  HardwareSerial Serial(&rx_buffer, &tx_buffer, &UBRR0H, &UBRR0L, &UCSR0A, &UCSR0B, &UDR0, RXEN0, TXEN0, RXCIE0, UDRIE0, U2X0);
     dca:	08 95       	ret

00000dcc <_ZN5Print5writeEPKhj>:
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
     dcc:	cf 92       	push	r12
     dce:	df 92       	push	r13
     dd0:	ef 92       	push	r14
     dd2:	ff 92       	push	r15
     dd4:	0f 93       	push	r16
     dd6:	1f 93       	push	r17
     dd8:	cf 93       	push	r28
     dda:	df 93       	push	r29
     ddc:	7c 01       	movw	r14, r24
     dde:	6b 01       	movw	r12, r22
     de0:	8a 01       	movw	r16, r20
     de2:	c0 e0       	ldi	r28, 0x00	; 0
     de4:	d0 e0       	ldi	r29, 0x00	; 0
     de6:	0f c0       	rjmp	.+30     	; 0xe06 <_ZN5Print5writeEPKhj+0x3a>
{
  size_t n = 0;
  while (size--) {
    n += write(*buffer++);
     de8:	d6 01       	movw	r26, r12
     dea:	6d 91       	ld	r22, X+
     dec:	6d 01       	movw	r12, r26
     dee:	d7 01       	movw	r26, r14
     df0:	ed 91       	ld	r30, X+
     df2:	fc 91       	ld	r31, X
     df4:	01 90       	ld	r0, Z+
     df6:	f0 81       	ld	r31, Z
     df8:	e0 2d       	mov	r30, r0
     dfa:	c7 01       	movw	r24, r14
     dfc:	09 95       	icall
     dfe:	c8 0f       	add	r28, r24
     e00:	d9 1f       	adc	r29, r25
     e02:	01 50       	subi	r16, 0x01	; 1
     e04:	10 40       	sbci	r17, 0x00	; 0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
     e06:	01 15       	cp	r16, r1
     e08:	11 05       	cpc	r17, r1
     e0a:	71 f7       	brne	.-36     	; 0xde8 <_ZN5Print5writeEPKhj+0x1c>
    n += write(*buffer++);
  }
  return n;
}
     e0c:	ce 01       	movw	r24, r28
     e0e:	df 91       	pop	r29
     e10:	cf 91       	pop	r28
     e12:	1f 91       	pop	r17
     e14:	0f 91       	pop	r16
     e16:	ff 90       	pop	r15
     e18:	ef 90       	pop	r14
     e1a:	df 90       	pop	r13
     e1c:	cf 90       	pop	r12
     e1e:	08 95       	ret

00000e20 <_ZN5Print7printlnEv>:
size_t Print::print(const Printable& x)
{
  return x.printTo(*this);
}

size_t Print::println(void)
     e20:	ef 92       	push	r14
     e22:	ff 92       	push	r15
     e24:	0f 93       	push	r16
     e26:	1f 93       	push	r17
     e28:	8c 01       	movw	r16, r24
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
     e2a:	dc 01       	movw	r26, r24
     e2c:	ed 91       	ld	r30, X+
     e2e:	fc 91       	ld	r31, X
     e30:	01 90       	ld	r0, Z+
     e32:	f0 81       	ld	r31, Z
     e34:	e0 2d       	mov	r30, r0
     e36:	6d e0       	ldi	r22, 0x0D	; 13
     e38:	09 95       	icall
     e3a:	7c 01       	movw	r14, r24
size_t Print::println(void)
{
  size_t n = print('\r');
  n += print('\n');
  return n;
}
     e3c:	d8 01       	movw	r26, r16
     e3e:	ed 91       	ld	r30, X+
     e40:	fc 91       	ld	r31, X
     e42:	01 90       	ld	r0, Z+
     e44:	f0 81       	ld	r31, Z
     e46:	e0 2d       	mov	r30, r0
     e48:	c8 01       	movw	r24, r16
     e4a:	6a e0       	ldi	r22, 0x0A	; 10
     e4c:	09 95       	icall
     e4e:	9c 01       	movw	r18, r24
     e50:	2e 0d       	add	r18, r14
     e52:	3f 1d       	adc	r19, r15
     e54:	c9 01       	movw	r24, r18
     e56:	1f 91       	pop	r17
     e58:	0f 91       	pop	r16
     e5a:	ff 90       	pop	r15
     e5c:	ef 90       	pop	r14
     e5e:	08 95       	ret

00000e60 <_ZN5Print5writeEPKc>:
  
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }
  
    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) { return write((const uint8_t *)str, strlen(str)); }
     e60:	cf 93       	push	r28
     e62:	df 93       	push	r29
     e64:	db 01       	movw	r26, r22
     e66:	0d 90       	ld	r0, X+
     e68:	00 20       	and	r0, r0
     e6a:	e9 f7       	brne	.-6      	; 0xe66 <_ZN5Print5writeEPKc+0x6>
     e6c:	11 97       	sbiw	r26, 0x01	; 1
     e6e:	a6 1b       	sub	r26, r22
     e70:	b7 0b       	sbc	r27, r23
     e72:	ec 01       	movw	r28, r24
     e74:	e8 81       	ld	r30, Y
     e76:	f9 81       	ldd	r31, Y+1	; 0x01
     e78:	02 80       	ldd	r0, Z+2	; 0x02
     e7a:	f3 81       	ldd	r31, Z+3	; 0x03
     e7c:	e0 2d       	mov	r30, r0
     e7e:	ad 01       	movw	r20, r26
     e80:	09 95       	icall
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	08 95       	ret

00000e88 <_ZN5Print7printlnEPKc>:
  size_t n = print(s);
  n += println();
  return n;
}

size_t Print::println(const char c[])
     e88:	ef 92       	push	r14
     e8a:	ff 92       	push	r15
     e8c:	0f 93       	push	r16
     e8e:	1f 93       	push	r17
     e90:	7c 01       	movw	r14, r24
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
     e92:	0e 94 30 07 	call	0xe60	; 0xe60 <_ZN5Print5writeEPKc>
     e96:	8c 01       	movw	r16, r24
}

size_t Print::println(const char c[])
{
  size_t n = print(c);
  n += println();
     e98:	c7 01       	movw	r24, r14
     e9a:	0e 94 10 07 	call	0xe20	; 0xe20 <_ZN5Print7printlnEv>
     e9e:	08 0f       	add	r16, r24
     ea0:	19 1f       	adc	r17, r25
  return n;
}
     ea2:	c8 01       	movw	r24, r16
     ea4:	1f 91       	pop	r17
     ea6:	0f 91       	pop	r16
     ea8:	ff 90       	pop	r15
     eaa:	ef 90       	pop	r14
     eac:	08 95       	ret

00000eae <main>:
#include <Arduino.h>

int main(void)
     eae:	cf 93       	push	r28
     eb0:	df 93       	push	r29
{
	init();
     eb2:	0e 94 07 08 	call	0x100e	; 0x100e <init>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
     eb6:	0e 94 c1 04 	call	0x982	; 0x982 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
     eba:	cd e1       	ldi	r28, 0x1D	; 29
     ebc:	d5 e0       	ldi	r29, 0x05	; 5
#endif
	
	setup();
    
	for (;;) {
		loop();
     ebe:	0e 94 7d 04 	call	0x8fa	; 0x8fa <loop>
		if (serialEventRun) serialEventRun();
     ec2:	20 97       	sbiw	r28, 0x00	; 0
     ec4:	e1 f3       	breq	.-8      	; 0xebe <main+0x10>
     ec6:	0e 94 1d 05 	call	0xa3a	; 0xa3a <_Z14serialEventRunv>
     eca:	f9 cf       	rjmp	.-14     	; 0xebe <main+0x10>

00000ecc <__vector_16>:
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
SIGNAL(TIM0_OVF_vect)
#else
SIGNAL(TIMER0_OVF_vect)
#endif
{
     ecc:	1f 92       	push	r1
     ece:	0f 92       	push	r0
     ed0:	0f b6       	in	r0, 0x3f	; 63
     ed2:	0f 92       	push	r0
     ed4:	11 24       	eor	r1, r1
     ed6:	2f 93       	push	r18
     ed8:	3f 93       	push	r19
     eda:	8f 93       	push	r24
     edc:	9f 93       	push	r25
     ede:	af 93       	push	r26
     ee0:	bf 93       	push	r27
	// copy these to local variables so they can be stored in registers
	// (volatile variables must be read from memory on every access)
	unsigned long m = timer0_millis;
     ee2:	80 91 47 02 	lds	r24, 0x0247
     ee6:	90 91 48 02 	lds	r25, 0x0248
     eea:	a0 91 49 02 	lds	r26, 0x0249
     eee:	b0 91 4a 02 	lds	r27, 0x024A
	unsigned char f = timer0_fract;
     ef2:	30 91 4b 02 	lds	r19, 0x024B

	m += MILLIS_INC;
     ef6:	01 96       	adiw	r24, 0x01	; 1
     ef8:	a1 1d       	adc	r26, r1
     efa:	b1 1d       	adc	r27, r1
	f += FRACT_INC;
     efc:	23 2f       	mov	r18, r19
     efe:	2d 5f       	subi	r18, 0xFD	; 253
	if (f >= FRACT_MAX) {
     f00:	2d 37       	cpi	r18, 0x7D	; 125
     f02:	20 f0       	brcs	.+8      	; 0xf0c <__vector_16+0x40>
		f -= FRACT_MAX;
     f04:	2d 57       	subi	r18, 0x7D	; 125
		m += 1;
     f06:	01 96       	adiw	r24, 0x01	; 1
     f08:	a1 1d       	adc	r26, r1
     f0a:	b1 1d       	adc	r27, r1
	}

	timer0_fract = f;
     f0c:	20 93 4b 02 	sts	0x024B, r18
	timer0_millis = m;
     f10:	80 93 47 02 	sts	0x0247, r24
     f14:	90 93 48 02 	sts	0x0248, r25
     f18:	a0 93 49 02 	sts	0x0249, r26
     f1c:	b0 93 4a 02 	sts	0x024A, r27
	timer0_overflow_count++;
     f20:	80 91 43 02 	lds	r24, 0x0243
     f24:	90 91 44 02 	lds	r25, 0x0244
     f28:	a0 91 45 02 	lds	r26, 0x0245
     f2c:	b0 91 46 02 	lds	r27, 0x0246
     f30:	01 96       	adiw	r24, 0x01	; 1
     f32:	a1 1d       	adc	r26, r1
     f34:	b1 1d       	adc	r27, r1
     f36:	80 93 43 02 	sts	0x0243, r24
     f3a:	90 93 44 02 	sts	0x0244, r25
     f3e:	a0 93 45 02 	sts	0x0245, r26
     f42:	b0 93 46 02 	sts	0x0246, r27
}
     f46:	bf 91       	pop	r27
     f48:	af 91       	pop	r26
     f4a:	9f 91       	pop	r25
     f4c:	8f 91       	pop	r24
     f4e:	3f 91       	pop	r19
     f50:	2f 91       	pop	r18
     f52:	0f 90       	pop	r0
     f54:	0f be       	out	0x3f, r0	; 63
     f56:	0f 90       	pop	r0
     f58:	1f 90       	pop	r1
     f5a:	18 95       	reti

00000f5c <delay>:
	
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
}

void delay(unsigned long ms)
{
     f5c:	9b 01       	movw	r18, r22
     f5e:	ac 01       	movw	r20, r24
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     f60:	7f b7       	in	r23, 0x3f	; 63
	
	cli();
     f62:	f8 94       	cli
	m = timer0_overflow_count;
     f64:	80 91 43 02 	lds	r24, 0x0243
     f68:	90 91 44 02 	lds	r25, 0x0244
     f6c:	a0 91 45 02 	lds	r26, 0x0245
     f70:	b0 91 46 02 	lds	r27, 0x0246
#if defined(TCNT0)
	t = TCNT0;
     f74:	66 b5       	in	r22, 0x26	; 38
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     f76:	a8 9b       	sbis	0x15, 0	; 21
     f78:	05 c0       	rjmp	.+10     	; 0xf84 <delay+0x28>
     f7a:	6f 3f       	cpi	r22, 0xFF	; 255
     f7c:	19 f0       	breq	.+6      	; 0xf84 <delay+0x28>
		m++;
     f7e:	01 96       	adiw	r24, 0x01	; 1
     f80:	a1 1d       	adc	r26, r1
     f82:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     f84:	7f bf       	out	0x3f, r23	; 63
	return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
}

void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();
     f86:	ba 2f       	mov	r27, r26
     f88:	a9 2f       	mov	r26, r25
     f8a:	98 2f       	mov	r25, r24
     f8c:	88 27       	eor	r24, r24
     f8e:	86 0f       	add	r24, r22
     f90:	91 1d       	adc	r25, r1
     f92:	a1 1d       	adc	r26, r1
     f94:	b1 1d       	adc	r27, r1
     f96:	62 e0       	ldi	r22, 0x02	; 2
     f98:	88 0f       	add	r24, r24
     f9a:	99 1f       	adc	r25, r25
     f9c:	aa 1f       	adc	r26, r26
     f9e:	bb 1f       	adc	r27, r27
     fa0:	6a 95       	dec	r22
     fa2:	d1 f7       	brne	.-12     	; 0xf98 <delay+0x3c>
     fa4:	bc 01       	movw	r22, r24
     fa6:	2d c0       	rjmp	.+90     	; 0x1002 <delay+0xa6>
	return m;
}

unsigned long micros() {
	unsigned long m;
	uint8_t oldSREG = SREG, t;
     fa8:	ff b7       	in	r31, 0x3f	; 63
	
	cli();
     faa:	f8 94       	cli
	m = timer0_overflow_count;
     fac:	80 91 43 02 	lds	r24, 0x0243
     fb0:	90 91 44 02 	lds	r25, 0x0244
     fb4:	a0 91 45 02 	lds	r26, 0x0245
     fb8:	b0 91 46 02 	lds	r27, 0x0246
#if defined(TCNT0)
	t = TCNT0;
     fbc:	e6 b5       	in	r30, 0x26	; 38
	#error TIMER 0 not defined
#endif

  
#ifdef TIFR0
	if ((TIFR0 & _BV(TOV0)) && (t < 255))
     fbe:	a8 9b       	sbis	0x15, 0	; 21
     fc0:	05 c0       	rjmp	.+10     	; 0xfcc <delay+0x70>
     fc2:	ef 3f       	cpi	r30, 0xFF	; 255
     fc4:	19 f0       	breq	.+6      	; 0xfcc <delay+0x70>
		m++;
     fc6:	01 96       	adiw	r24, 0x01	; 1
     fc8:	a1 1d       	adc	r26, r1
     fca:	b1 1d       	adc	r27, r1
#else
	if ((TIFR & _BV(TOV0)) && (t < 255))
		m++;
#endif

	SREG = oldSREG;
     fcc:	ff bf       	out	0x3f, r31	; 63
void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();

	while (ms > 0) {
		if (((uint16_t)micros() - start) >= 1000) {
     fce:	ba 2f       	mov	r27, r26
     fd0:	a9 2f       	mov	r26, r25
     fd2:	98 2f       	mov	r25, r24
     fd4:	88 27       	eor	r24, r24
     fd6:	8e 0f       	add	r24, r30
     fd8:	91 1d       	adc	r25, r1
     fda:	a1 1d       	adc	r26, r1
     fdc:	b1 1d       	adc	r27, r1
     fde:	e2 e0       	ldi	r30, 0x02	; 2
     fe0:	88 0f       	add	r24, r24
     fe2:	99 1f       	adc	r25, r25
     fe4:	aa 1f       	adc	r26, r26
     fe6:	bb 1f       	adc	r27, r27
     fe8:	ea 95       	dec	r30
     fea:	d1 f7       	brne	.-12     	; 0xfe0 <delay+0x84>
     fec:	86 1b       	sub	r24, r22
     fee:	97 0b       	sbc	r25, r23
     ff0:	88 5e       	subi	r24, 0xE8	; 232
     ff2:	93 40       	sbci	r25, 0x03	; 3
     ff4:	c8 f2       	brcs	.-78     	; 0xfa8 <delay+0x4c>
			ms--;
     ff6:	21 50       	subi	r18, 0x01	; 1
     ff8:	30 40       	sbci	r19, 0x00	; 0
     ffa:	40 40       	sbci	r20, 0x00	; 0
     ffc:	50 40       	sbci	r21, 0x00	; 0
			start += 1000;
     ffe:	68 51       	subi	r22, 0x18	; 24
    1000:	7c 4f       	sbci	r23, 0xFC	; 252

void delay(unsigned long ms)
{
	uint16_t start = (uint16_t)micros();

	while (ms > 0) {
    1002:	21 15       	cp	r18, r1
    1004:	31 05       	cpc	r19, r1
    1006:	41 05       	cpc	r20, r1
    1008:	51 05       	cpc	r21, r1
    100a:	71 f6       	brne	.-100    	; 0xfa8 <delay+0x4c>
		if (((uint16_t)micros() - start) >= 1000) {
			ms--;
			start += 1000;
		}
	}
}
    100c:	08 95       	ret

0000100e <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
    100e:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
    1010:	84 b5       	in	r24, 0x24	; 36
    1012:	82 60       	ori	r24, 0x02	; 2
    1014:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
    1016:	84 b5       	in	r24, 0x24	; 36
    1018:	81 60       	ori	r24, 0x01	; 1
    101a:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
    101c:	85 b5       	in	r24, 0x25	; 37
    101e:	82 60       	ori	r24, 0x02	; 2
    1020:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
    1022:	85 b5       	in	r24, 0x25	; 37
    1024:	81 60       	ori	r24, 0x01	; 1
    1026:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
    1028:	ee e6       	ldi	r30, 0x6E	; 110
    102a:	f0 e0       	ldi	r31, 0x00	; 0
    102c:	80 81       	ld	r24, Z
    102e:	81 60       	ori	r24, 0x01	; 1
    1030:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
    1032:	e1 e8       	ldi	r30, 0x81	; 129
    1034:	f0 e0       	ldi	r31, 0x00	; 0
    1036:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
    1038:	80 81       	ld	r24, Z
    103a:	82 60       	ori	r24, 0x02	; 2
    103c:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
    103e:	80 81       	ld	r24, Z
    1040:	81 60       	ori	r24, 0x01	; 1
    1042:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
    1044:	e0 e8       	ldi	r30, 0x80	; 128
    1046:	f0 e0       	ldi	r31, 0x00	; 0
    1048:	80 81       	ld	r24, Z
    104a:	81 60       	ori	r24, 0x01	; 1
    104c:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
    104e:	e1 eb       	ldi	r30, 0xB1	; 177
    1050:	f0 e0       	ldi	r31, 0x00	; 0
    1052:	80 81       	ld	r24, Z
    1054:	84 60       	ori	r24, 0x04	; 4
    1056:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
    1058:	e0 eb       	ldi	r30, 0xB0	; 176
    105a:	f0 e0       	ldi	r31, 0x00	; 0
    105c:	80 81       	ld	r24, Z
    105e:	81 60       	ori	r24, 0x01	; 1
    1060:	80 83       	st	Z, r24
#if defined(ADCSRA)
	// set a2d prescale factor to 128
	// 16 MHz / 128 = 125 KHz, inside the desired 50-200 KHz range.
	// XXX: this will not work properly for other clock speeds, and
	// this code should use F_CPU to determine the prescale factor.
	sbi(ADCSRA, ADPS2);
    1062:	ea e7       	ldi	r30, 0x7A	; 122
    1064:	f0 e0       	ldi	r31, 0x00	; 0
    1066:	80 81       	ld	r24, Z
    1068:	84 60       	ori	r24, 0x04	; 4
    106a:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS1);
    106c:	80 81       	ld	r24, Z
    106e:	82 60       	ori	r24, 0x02	; 2
    1070:	80 83       	st	Z, r24
	sbi(ADCSRA, ADPS0);
    1072:	80 81       	ld	r24, Z
    1074:	81 60       	ori	r24, 0x01	; 1
    1076:	80 83       	st	Z, r24

	// enable a2d conversions
	sbi(ADCSRA, ADEN);
    1078:	80 81       	ld	r24, Z
    107a:	80 68       	ori	r24, 0x80	; 128
    107c:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
    107e:	10 92 c1 00 	sts	0x00C1, r1
#endif
}
    1082:	08 95       	ret

00001084 <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
    1084:	cf 93       	push	r28
    1086:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
    1088:	48 2f       	mov	r20, r24
    108a:	50 e0       	ldi	r21, 0x00	; 0
    108c:	ca 01       	movw	r24, r20
    108e:	86 5d       	subi	r24, 0xD6	; 214
    1090:	9e 4f       	sbci	r25, 0xFE	; 254
    1092:	fc 01       	movw	r30, r24
    1094:	34 91       	lpm	r19, Z+
	uint8_t port = digitalPinToPort(pin);
    1096:	4a 5e       	subi	r20, 0xEA	; 234
    1098:	5e 4f       	sbci	r21, 0xFE	; 254
    109a:	fa 01       	movw	r30, r20
    109c:	84 91       	lpm	r24, Z+
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
    109e:	88 23       	and	r24, r24
    10a0:	69 f1       	breq	.+90     	; 0x10fc <pinMode+0x78>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
    10a2:	90 e0       	ldi	r25, 0x00	; 0
    10a4:	88 0f       	add	r24, r24
    10a6:	99 1f       	adc	r25, r25
    10a8:	fc 01       	movw	r30, r24
    10aa:	e8 50       	subi	r30, 0x08	; 8
    10ac:	ff 4f       	sbci	r31, 0xFF	; 255
    10ae:	a5 91       	lpm	r26, Z+
    10b0:	b4 91       	lpm	r27, Z+
	out = portOutputRegister(port);
    10b2:	fc 01       	movw	r30, r24
    10b4:	ee 5f       	subi	r30, 0xFE	; 254
    10b6:	fe 4f       	sbci	r31, 0xFE	; 254
    10b8:	c5 91       	lpm	r28, Z+
    10ba:	d4 91       	lpm	r29, Z+

	if (mode == INPUT) { 
    10bc:	66 23       	and	r22, r22
    10be:	51 f4       	brne	.+20     	; 0x10d4 <pinMode+0x50>
		uint8_t oldSREG = SREG;
    10c0:	2f b7       	in	r18, 0x3f	; 63
                cli();
    10c2:	f8 94       	cli
		*reg &= ~bit;
    10c4:	8c 91       	ld	r24, X
    10c6:	93 2f       	mov	r25, r19
    10c8:	90 95       	com	r25
    10ca:	89 23       	and	r24, r25
    10cc:	8c 93       	st	X, r24
		*out &= ~bit;
    10ce:	88 81       	ld	r24, Y
    10d0:	89 23       	and	r24, r25
    10d2:	0b c0       	rjmp	.+22     	; 0x10ea <pinMode+0x66>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
    10d4:	62 30       	cpi	r22, 0x02	; 2
    10d6:	61 f4       	brne	.+24     	; 0x10f0 <pinMode+0x6c>
		uint8_t oldSREG = SREG;
    10d8:	2f b7       	in	r18, 0x3f	; 63
                cli();
    10da:	f8 94       	cli
		*reg &= ~bit;
    10dc:	8c 91       	ld	r24, X
    10de:	93 2f       	mov	r25, r19
    10e0:	90 95       	com	r25
    10e2:	89 23       	and	r24, r25
    10e4:	8c 93       	st	X, r24
		*out |= bit;
    10e6:	88 81       	ld	r24, Y
    10e8:	83 2b       	or	r24, r19
    10ea:	88 83       	st	Y, r24
		SREG = oldSREG;
    10ec:	2f bf       	out	0x3f, r18	; 63
    10ee:	06 c0       	rjmp	.+12     	; 0x10fc <pinMode+0x78>
	} else {
		uint8_t oldSREG = SREG;
    10f0:	9f b7       	in	r25, 0x3f	; 63
                cli();
    10f2:	f8 94       	cli
		*reg |= bit;
    10f4:	8c 91       	ld	r24, X
    10f6:	83 2b       	or	r24, r19
    10f8:	8c 93       	st	X, r24
		SREG = oldSREG;
    10fa:	9f bf       	out	0x3f, r25	; 63
	}
}
    10fc:	df 91       	pop	r29
    10fe:	cf 91       	pop	r28
    1100:	08 95       	ret

00001102 <digitalWrite>:
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
	uint8_t timer = digitalPinToTimer(pin);
    1102:	48 2f       	mov	r20, r24
    1104:	50 e0       	ldi	r21, 0x00	; 0
    1106:	ca 01       	movw	r24, r20
    1108:	82 5c       	subi	r24, 0xC2	; 194
    110a:	9e 4f       	sbci	r25, 0xFE	; 254
    110c:	fc 01       	movw	r30, r24
    110e:	24 91       	lpm	r18, Z+
	uint8_t bit = digitalPinToBitMask(pin);
    1110:	ca 01       	movw	r24, r20
    1112:	86 5d       	subi	r24, 0xD6	; 214
    1114:	9e 4f       	sbci	r25, 0xFE	; 254
    1116:	fc 01       	movw	r30, r24
    1118:	94 91       	lpm	r25, Z+
	uint8_t port = digitalPinToPort(pin);
    111a:	4a 5e       	subi	r20, 0xEA	; 234
    111c:	5e 4f       	sbci	r21, 0xFE	; 254
    111e:	fa 01       	movw	r30, r20
    1120:	34 91       	lpm	r19, Z+
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
    1122:	33 23       	and	r19, r19
    1124:	09 f4       	brne	.+2      	; 0x1128 <digitalWrite+0x26>
    1126:	40 c0       	rjmp	.+128    	; 0x11a8 <digitalWrite+0xa6>

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
    1128:	22 23       	and	r18, r18
    112a:	51 f1       	breq	.+84     	; 0x1180 <digitalWrite+0x7e>
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
    112c:	23 30       	cpi	r18, 0x03	; 3
    112e:	71 f0       	breq	.+28     	; 0x114c <digitalWrite+0x4a>
    1130:	24 30       	cpi	r18, 0x04	; 4
    1132:	28 f4       	brcc	.+10     	; 0x113e <digitalWrite+0x3c>
    1134:	21 30       	cpi	r18, 0x01	; 1
    1136:	a1 f0       	breq	.+40     	; 0x1160 <digitalWrite+0x5e>
    1138:	22 30       	cpi	r18, 0x02	; 2
    113a:	11 f5       	brne	.+68     	; 0x1180 <digitalWrite+0x7e>
    113c:	14 c0       	rjmp	.+40     	; 0x1166 <digitalWrite+0x64>
    113e:	26 30       	cpi	r18, 0x06	; 6
    1140:	b1 f0       	breq	.+44     	; 0x116e <digitalWrite+0x6c>
    1142:	27 30       	cpi	r18, 0x07	; 7
    1144:	c1 f0       	breq	.+48     	; 0x1176 <digitalWrite+0x74>
    1146:	24 30       	cpi	r18, 0x04	; 4
    1148:	d9 f4       	brne	.+54     	; 0x1180 <digitalWrite+0x7e>
    114a:	04 c0       	rjmp	.+8      	; 0x1154 <digitalWrite+0x52>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
    114c:	80 91 80 00 	lds	r24, 0x0080
    1150:	8f 77       	andi	r24, 0x7F	; 127
    1152:	03 c0       	rjmp	.+6      	; 0x115a <digitalWrite+0x58>
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
    1154:	80 91 80 00 	lds	r24, 0x0080
    1158:	8f 7d       	andi	r24, 0xDF	; 223
    115a:	80 93 80 00 	sts	0x0080, r24
    115e:	10 c0       	rjmp	.+32     	; 0x1180 <digitalWrite+0x7e>
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
    1160:	84 b5       	in	r24, 0x24	; 36
    1162:	8f 77       	andi	r24, 0x7F	; 127
    1164:	02 c0       	rjmp	.+4      	; 0x116a <digitalWrite+0x68>
		#endif
		
		#if defined(TIMER0B) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
    1166:	84 b5       	in	r24, 0x24	; 36
    1168:	8f 7d       	andi	r24, 0xDF	; 223
    116a:	84 bd       	out	0x24, r24	; 36
    116c:	09 c0       	rjmp	.+18     	; 0x1180 <digitalWrite+0x7e>
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
    116e:	80 91 b0 00 	lds	r24, 0x00B0
    1172:	8f 77       	andi	r24, 0x7F	; 127
    1174:	03 c0       	rjmp	.+6      	; 0x117c <digitalWrite+0x7a>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
    1176:	80 91 b0 00 	lds	r24, 0x00B0
    117a:	8f 7d       	andi	r24, 0xDF	; 223
    117c:	80 93 b0 00 	sts	0x00B0, r24

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);

	out = portOutputRegister(port);
    1180:	e3 2f       	mov	r30, r19
    1182:	f0 e0       	ldi	r31, 0x00	; 0
    1184:	ee 0f       	add	r30, r30
    1186:	ff 1f       	adc	r31, r31
    1188:	ee 5f       	subi	r30, 0xFE	; 254
    118a:	fe 4f       	sbci	r31, 0xFE	; 254
    118c:	a5 91       	lpm	r26, Z+
    118e:	b4 91       	lpm	r27, Z+

	uint8_t oldSREG = SREG;
    1190:	2f b7       	in	r18, 0x3f	; 63
	cli();
    1192:	f8 94       	cli

	if (val == LOW) {
    1194:	66 23       	and	r22, r22
    1196:	21 f4       	brne	.+8      	; 0x11a0 <digitalWrite+0x9e>
		*out &= ~bit;
    1198:	8c 91       	ld	r24, X
    119a:	90 95       	com	r25
    119c:	89 23       	and	r24, r25
    119e:	02 c0       	rjmp	.+4      	; 0x11a4 <digitalWrite+0xa2>
	} else {
		*out |= bit;
    11a0:	8c 91       	ld	r24, X
    11a2:	89 2b       	or	r24, r25
    11a4:	8c 93       	st	X, r24
	}

	SREG = oldSREG;
    11a6:	2f bf       	out	0x3f, r18	; 63
    11a8:	08 95       	ret

000011aa <__divmodhi4>:
    11aa:	97 fb       	bst	r25, 7
    11ac:	09 2e       	mov	r0, r25
    11ae:	07 26       	eor	r0, r23
    11b0:	0a d0       	rcall	.+20     	; 0x11c6 <__divmodhi4_neg1>
    11b2:	77 fd       	sbrc	r23, 7
    11b4:	04 d0       	rcall	.+8      	; 0x11be <__divmodhi4_neg2>
    11b6:	2e d0       	rcall	.+92     	; 0x1214 <__udivmodhi4>
    11b8:	06 d0       	rcall	.+12     	; 0x11c6 <__divmodhi4_neg1>
    11ba:	00 20       	and	r0, r0
    11bc:	1a f4       	brpl	.+6      	; 0x11c4 <__divmodhi4_exit>

000011be <__divmodhi4_neg2>:
    11be:	70 95       	com	r23
    11c0:	61 95       	neg	r22
    11c2:	7f 4f       	sbci	r23, 0xFF	; 255

000011c4 <__divmodhi4_exit>:
    11c4:	08 95       	ret

000011c6 <__divmodhi4_neg1>:
    11c6:	f6 f7       	brtc	.-4      	; 0x11c4 <__divmodhi4_exit>
    11c8:	90 95       	com	r25
    11ca:	81 95       	neg	r24
    11cc:	9f 4f       	sbci	r25, 0xFF	; 255
    11ce:	08 95       	ret

000011d0 <__udivmodsi4>:
    11d0:	a1 e2       	ldi	r26, 0x21	; 33
    11d2:	1a 2e       	mov	r1, r26
    11d4:	aa 1b       	sub	r26, r26
    11d6:	bb 1b       	sub	r27, r27
    11d8:	fd 01       	movw	r30, r26
    11da:	0d c0       	rjmp	.+26     	; 0x11f6 <__udivmodsi4_ep>

000011dc <__udivmodsi4_loop>:
    11dc:	aa 1f       	adc	r26, r26
    11de:	bb 1f       	adc	r27, r27
    11e0:	ee 1f       	adc	r30, r30
    11e2:	ff 1f       	adc	r31, r31
    11e4:	a2 17       	cp	r26, r18
    11e6:	b3 07       	cpc	r27, r19
    11e8:	e4 07       	cpc	r30, r20
    11ea:	f5 07       	cpc	r31, r21
    11ec:	20 f0       	brcs	.+8      	; 0x11f6 <__udivmodsi4_ep>
    11ee:	a2 1b       	sub	r26, r18
    11f0:	b3 0b       	sbc	r27, r19
    11f2:	e4 0b       	sbc	r30, r20
    11f4:	f5 0b       	sbc	r31, r21

000011f6 <__udivmodsi4_ep>:
    11f6:	66 1f       	adc	r22, r22
    11f8:	77 1f       	adc	r23, r23
    11fa:	88 1f       	adc	r24, r24
    11fc:	99 1f       	adc	r25, r25
    11fe:	1a 94       	dec	r1
    1200:	69 f7       	brne	.-38     	; 0x11dc <__udivmodsi4_loop>
    1202:	60 95       	com	r22
    1204:	70 95       	com	r23
    1206:	80 95       	com	r24
    1208:	90 95       	com	r25
    120a:	9b 01       	movw	r18, r22
    120c:	ac 01       	movw	r20, r24
    120e:	bd 01       	movw	r22, r26
    1210:	cf 01       	movw	r24, r30
    1212:	08 95       	ret

00001214 <__udivmodhi4>:
    1214:	aa 1b       	sub	r26, r26
    1216:	bb 1b       	sub	r27, r27
    1218:	51 e1       	ldi	r21, 0x11	; 17
    121a:	07 c0       	rjmp	.+14     	; 0x122a <__udivmodhi4_ep>

0000121c <__udivmodhi4_loop>:
    121c:	aa 1f       	adc	r26, r26
    121e:	bb 1f       	adc	r27, r27
    1220:	a6 17       	cp	r26, r22
    1222:	b7 07       	cpc	r27, r23
    1224:	10 f0       	brcs	.+4      	; 0x122a <__udivmodhi4_ep>
    1226:	a6 1b       	sub	r26, r22
    1228:	b7 0b       	sbc	r27, r23

0000122a <__udivmodhi4_ep>:
    122a:	88 1f       	adc	r24, r24
    122c:	99 1f       	adc	r25, r25
    122e:	5a 95       	dec	r21
    1230:	a9 f7       	brne	.-22     	; 0x121c <__udivmodhi4_loop>
    1232:	80 95       	com	r24
    1234:	90 95       	com	r25
    1236:	bc 01       	movw	r22, r24
    1238:	cd 01       	movw	r24, r26
    123a:	08 95       	ret

0000123c <__tablejump2__>:
    123c:	ee 0f       	add	r30, r30
    123e:	ff 1f       	adc	r31, r31

00001240 <__tablejump__>:
    1240:	05 90       	lpm	r0, Z+
    1242:	f4 91       	lpm	r31, Z+
    1244:	e0 2d       	mov	r30, r0
    1246:	09 94       	ijmp

00001248 <__do_global_dtors>:
    1248:	11 e0       	ldi	r17, 0x01	; 1
    124a:	c6 e5       	ldi	r28, 0x56	; 86
    124c:	d1 e0       	ldi	r29, 0x01	; 1
    124e:	04 c0       	rjmp	.+8      	; 0x1258 <.do_global_dtors_start>

00001250 <.do_global_dtors_loop>:
    1250:	fe 01       	movw	r30, r28
    1252:	0e 94 20 09 	call	0x1240	; 0x1240 <__tablejump__>
    1256:	22 96       	adiw	r28, 0x02	; 2

00001258 <.do_global_dtors_start>:
    1258:	c8 35       	cpi	r28, 0x58	; 88
    125a:	d1 07       	cpc	r29, r17
    125c:	c9 f7       	brne	.-14     	; 0x1250 <.do_global_dtors_loop>
    125e:	f8 94       	cli

00001260 <__stop_program>:
    1260:	ff cf       	rjmp	.-2      	; 0x1260 <__stop_program>
